<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Claude Artifact</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Claude Artifact</p>
                        <p>Enter the password to view this artifact.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"81cda0cfbf901d85f8d6d9fc0105324a929f98f4c77e6bc3f5600c62af7b586baf7f279610b286565e7ffb3aaa5d9dbcc6e982b748fbf86a565f78a90a5de1be711165c83580a1f40bf92c5aacb3ecf9a3ed8baec09e86295e440bb9b970c7c4b37e0b1e19cf444aac9b665b3b71a270bd4764eb75a067fe3b189a5db9cde36c53066cb0ace4ebc66b000032ad4a00094062b5ea342775acc3f68d7ddcc1b4b561865b956e02df954cd90929397879b2663db1437fc498416a0ac75dec4a2e31abd130421ef97858398008f869a1e7e928f48003a45b3a148777b68ce5ce8a0c783f2611f3b8b8f9fee44bbe31dfdc91eef6ed6242ac08aa1c40ee16bc494339e8b911cf997777b93e7535819094e86f4bfbea44b1f7954c864c1873d791e68cf1884e9d8ca4c9257845a142ffab730bf2377b43e3dd3126dbd31d15a1746473b308f839bf56ab82d1bed91bf1def8884c600a3fb7d64ed16ec83e106284a51255402e5be27851625519201bb2b7af0cfe53f6d4ddf3945e9caeff7c584ee42c744ca48976b0575bc383eeedc9134c54d1fe4b53d7a874592bbedecee7e1be3edcb9f73363b7aa1c30f5baec73a75463623f2f8367b26b605f95464f3045d5845d35f2a6b8893c7e051701ab519de023cb59c919fe3cd1c6cc9d17a210ceadbd64b897efd27f1e514202696d9fc63955f0830695da65a2300b41a74eb00a4e958741c0e4127940810976345cb0ba2a67d33a2aa1c4ed2ef7b58210ffbd3369dbe5b04515061dd68e9c9330937120c57a539b51477944b479f7e6de514da606d0739da46a0de4d12a5da63e5aad725b560fbdccec6bec24e69ee28f9ac2724d8fafcc9ed224de78ca78134118143122ac4f1fdef626c4ad0855526a9e9640d6406df5fe2fba79012e8bab364a01a2480c8c69883c42d9adb4875f9e33e933b563e43afe57335852cfee029137a5437ffa9be01b16f85a4a332143b55a3a099575b64d26446bac2e89e24b4a57cfb476772c87406e73fe67d59619a75b42b4e306e236e660be5efb38eb3489a9b8d6af275b620d2c3ed786581d90e9d229c51a1e3122c4e260c8f8932d924da5736b35d5061f53b20015dd9057c80311dd5ef40b17277990376a0c1900f800ad0598d5c787865465c658c634dadefa4d136df07bdbbc64c34306325d4030fec4b0ccfd53cd54b98694edaf7abd3fb148eadfd2c8d667fa03f7eb3cf181f6861401b79e55ad577f0f5c1aeaa4b2e16a3f58db50ea9b1bcec26838bdc15c74b6a496d227c0a5e4b9e261686d5165d00524b8abaf73c2d831d3215e568ae2d24daad146f6a260190b9876b2895087c704c68ee85f36a7b794eda16c405ea468618f9ebf8e55b2a0f101a7db2a1b7c7a96ea544e20e821d1c4bfd32fb800c63e5f18a5340ead494665566ce0f853b1b1ad60956cb52df8dd11fae774c2d5408099ce52f47839e31fbf4918700c1e0ed468718078ef123490955561d089c358431b3abe418e22dfcc54354c16257216ec41771b883a951fb4cb84a2e0b69b6a125ec68da76231c372cb2657e20eedf684f72998e11f7d356142be992237fedb7efad9c5c1d50e7a765f5d228649a6527cec004075a0266f6e5591dcea0d54efdc46b7289f22d55dbd3562cc85dd3cc1e9c2a720ba45c64a31afda90db3da8cae7a7cb2cfc6d87ac5974732439ccc933aa142c58abe6465deb94aea3902a6cfd816b108c17755ff5ba5d8e9258e196edf1ff104f179a742e5a5baf8fecdfc30469386dae777136ab0de05eea5746b1a9b1c27c19c8e56337b9c108a9c5ca961d301238915b30a8fcdf9b0c0f108509dfb266c4a85c681c18f9daabbdfbf72e24c2a6f96b3d6aaea032012544c8b2a88508f8e1febe9fcae128f1bb42ff687537697cf07d734f5acbd526a8c3bc70c7817951d833ab3a4355ed0c105d1853ef6fc44b0087df1b9f8198cd8d6c9abc74274b766ed0d02e80bfd335b2e694d5056c5fc3ef1ad1a8a74885d4659bdb9eb276da97fff9c9090accd566b7ef7ecddea05c3a5c3fdd5e081e720bb8d5ab6edd94c79d90deae5fe23bcc280ab553ee3780ee2656c690ace586806878bf7d74382981746d1f3d3b02325109407261f1785ec4239792cfe3b49aed946ae620bf87521dfbb69484b0f082662717a32d4127ef260b4d716129657dd568abcbe7d9d62842dd61cf3d8c07b5c5c65c91c9a28114d0e1e7d4e58ff1452366072eee44a5b4ef66517d3185828a7272d29037a35f87797ab5a04364914e321e8bd03535eb3e39334e0dbebdefc67645028e8f3904b42b08e4f0d58e374f8498f6df242f65808517b13417086af107b8805393f418cc34c00150fd71859f5f8c160f0fedf4a44d149d9cd315e129796bd3da8ee20419d2c82eb60265acc080f92a5d98f01824d93806d89062f2197c59ce24d2cdb762cccfb3490c7a88cb83540c931a8165b4850c83a088da3ad342f180c7c9ef71149b552a5723efa3a940e213c4df0378aab3bd36851da5d52d3e3a9415e8ce4b9449bdfcd401d987b39a58f1255ee79da0bc52b136e93d7f2842c1cc7841f659761d5be50f682d627d339b02d9e9aa64f286fcd97b1d478de711f1b3b68a4c59d885ff5510121b72b712e5bc91db5e425d9b2643582c28f5ad3ca5a70777176ffe06d4b2813bdd62b3b3d34d8edee96d1dc6cba0458878fbe856636393ecce0a9fe283bca42cc09919a776aa9bdedc0c7b10d6f637e24433299feb67c2f918de6437f661d44d6623a4b0259a9e7283ca1a410712c8fbe570a7d5eac03f9b1a42591318af410fdfac81689d4438096a0b9b1cfdbf3d444808eb9fc6c1e1fd28832971123b469e74348114b8e29f4f4c832fbfe28b7c4c6ba167f5478b823dccfd6b4397a08eed45f2defa49c5dfc16daff58337338cb5296c791798658699b75dafa62f540e568638e644f29cf7969f9df3250b59c11989d7bf8179b09b9ba725d207cb721ef6adf5303c7a837c890c6edd8f04f58fd44b0946d5962d18365054bf656f739047b2abbcb02a88a50cdfd7d497c1970517882c9cb44829b797f59737a1457607e70bef4ad9bf0bef1ff6ea7d8e60144a132fb031a1a47134e4d3787f2ab0438c7145b08568df533f6ff87728b4c3a21022eee87809f597b8b20217c11ef355d266f47b245efa3951729efefdfe8dccdfb598f63f9675433921b8f8881df77c31b3a940cd9db2c2d448ac1ae7f535fc4cb6a7c4818bf1aaa48a537936b5511f389491c9e678a94b91ca8eae94bd43a197a948cac01607f4d8a127ea890f62295f8752f8fa75e465b697adde09899a6ec33e30453a5dabac3cd6a6403b31e600725544ce40b66a41d5f2eab94be7eb3770e1e49b4a19bc064c6b979f8de216a3f2ff3790c0f5b5abf73fb9531d23d29fae09a0452bf3e47980c7080e2b11be6221b0af49ca389463ab9f221aaa53c87b7ee86757ae0b3f9a49d33b51ecf7175261fe7674921f8f19d2c22bf313a971ed91517e729fcd89b355630aae93c0404412d8dc6ea4a003cd6ebd6c6b3237ed00ad38142a2a886945c203d2f982d3cabaefe35203b11f122647d6de713b828fce4554d3a7f89654f7a59ba5250e6017489948aeba73cfe79f6cc373672328a2288476d5dad434fc195b55a45bdae9570bc216cdd0140d652099bcfe626a2a0e93d4195ab427786b84322cbac05ef7f9b1ff342ea6bedac0f31118f0d23eb3ff0c0f40763359123093cfcdf9724737b25c50b3a49ad1f13d9cef1dbee99f521de2ec0e80b3585e28339a3e23ad2c35b509e3002c2238f34dac654096bc27642e74a00ef17134b78b05687b276aa5729be559a1613e5eff9407537ce2ab4653531be8874cf639fddaeb2a04f5f6c2d11a6d6175ee39fd238b43570368ea6e92aead6e1e6ebeb042f3e56b7849e0beacd2cb787c037b7994135f564123dc9096b98d0f22c3fb8588a2703b2a3b6a458d1dc9418c9999d5c418f0fba948ee63bfa6111f8a3b46853aefb186d50a5ff001ddfb8da7eeee72a48fb0d164900d6f311892e80bd5bc0aecd87fae440d022e6090adb892d9540d12092b00d30e2af3aadb232a964113474b28152d47130d5992ddd7d58e3def6cb3a3bfda939bbb3b6005591fce098f06511c04d4d60b91f4c284210cbf96bde9324873bc70e817a0db76cfd319ef449389cf4e6259d24d76781a74574ef8de2abf04bdd85d58d875737cbd8a2e7289f65c79b7bd11c282d9ed5c9d15f535716f40cdb850bd43fa705fd01d1d0026bf123d4cf6d563b14dbe712329bd6a63da305c84485ad3b1765af67a8193b5e1b5d1bc258a9c57a6ad6333b5ba21f2a8fb5edb0c03dbaaa4f0528971c6cff15cf2c5754bd9a3457b42362d96d6096110f7923b1d612e9da06049cf28481250a4944920dfdffb234e9e044227745ea561b29079a26e7a5da12ac43856c53fc4ad999eb598284be2b61cd35b217cc46599a444fc16dfc45468e183bb25bb5ddc83dc1e8d5b22097e5d0f05bb2f5d1aae27b3c594895a2b4d7551ad2b103c7a1ff64781b8fb59e8f347b0b59d21b16aab8299bc60a79e8e8f979a58977aa0cf2fd1a34a90c7a888bee1bfb87aeb843ea5cd0ad6043aaf229db57bebc76c15b474281f0f5762a771518aab3c8bcbc6ec3116f68a81bd144138a3a318712ba63a5d0ca0d3a966755b6ebb7458bc6481d2f08c5aa7e2914d35ad7732877d892ba07846a5ce5dd5159fbc6ed54d74a19af9a251dd84b1b6a630b29f3362b107ff91aa3a3908409822164d3c4b7002df5504d95b35ab3320350865b13a781f361ee94edb7891b18c98bbf473bddfc7d4eb7e969f531b3397ed55ce1c38cdd7bb60227280c3f6be9901a2f988be7361cab736322ce845205294eecc7cd63da4bedb301db9a66c9108b5f9f08f98f63dd30a35e3ef2ca736ed68a1249762c498393f7d3b1a20a6f8ed536d88ba8b83f853534f70328ddad3c11933ccb64a8f00a8c96d90125c6e8f87a38a6df4387614a054161171ab676b860037c18facf55d3f261bd1313b2f1beb15e24675852085e24d49b4212360cd04c20316cb4ae6d6790e01a77a8c55079d7997c8e2b7cbdbe7631c8cd392218db7bf9219d8facbb6113eea0effb839c96c49a53f32b9700eea8cdaf4635755582eb4b988cf56d7aec9aa21f2244e8edd8bf484958b78677f33c4b5ef7c93688662e9457a754eea24b9ba6d7606f7d8b8332bfe09e5c54f45dc12c96ba3f1e830a6d0abef7571c58f9abbe1502303707cce3a0febd685621f2a1206a18ad599503ac92b854ab7d5d354339cab6c1511696c111467836ce39e825318f8ab5b131bf08f28dff1ff4832df5dc4354356867c6b0106dac736c6e8bd7ecb7e3fa58ff91316b3739811260f19e9ef6f905e38e2650573a9d257f14609577c8fa4e046fbaab4442121da03edf7e611fb80181a28b4108bd5d21f2cb03bb9d39c7d8db0c2f1674f5c7cc3a2d9eac8b51babeccbff01ef80fcac53ea3396c717b7007442e76268612c39ad9934d1db13594f1c7e3f4fa215b0f9d3e6154d0c3c15a17dba487cdeade092e5b2586817ad859cca854842a0c31edeba70ab49a291cc0d9c895f010464b7b10de69ca5789e6adaeaf17aaaad080d2a23a5d0acae1f2d8158ea0ac6dd97ad6a2735660a782cb846b18f8eea77f29d63bf3dea8ebf5c33a96b9704fd9e68c14defb5feff97410d40b270387e564b9545da5a470996fef8e84f299e67ca9185d6127665e59c5f97e3b0813e2143f7091f71946759ab7f50c22d8be4a2b54ac4b8c79a8965d0ea88b2490de4de6097b9ae0dc4539e2acc8348559477abff5c9f39f2d3897e08f06e50f41803c999702197fbc875c2832870d3556a80889b2b9ff0933494c2fca7e57b8dfd61170eb7d37fda2b02624a0879eb000cf71b35b8380fec06321741a6d38becc0f6b6f8a9c1ea0868ed589cfe7c224a9de49c0cac5280a6e6074d1a8841b641d3b1156393f78273edf028594e7c30a3a6e18555cb84b64b14bba9f54b984cffdedd79a1d3b9e002d8e54df188f728832c99d591961a43b1a8c5edb090cc12d525586e878ea8552151d1a5bed9e8d9a944d8b334c8476bf1b991e82a1ab6212d65e1d27a9c361e5271eae026e32781b8cfc4ac44b15355ccfd102b34e18f70dd3f5a7d23930798095cc55b873dce9090dbf4902c5fb111172bc3f0137cdc58761fc9a32a85f67bb0296f000f7c6e8e4ebd9e05c5d8e210ad5c51e0b2f982dadc4cc04b0da940c857a70d3b02a53461819db541211f873222fca472d4203efc533e01832eb337b67cd78608d12a8af7ee63ead69b907f12e5ae7e53a803b61787352a09c359187763eca60e385c6f68097f8dfdbaaf48489d713929b103e126ab63b6d86e439cb94008be4c2fe77eb3a1537787e52311c7c97db4393030dd6c761f09c79ed4b086c2f13ddea6f7247a8cdfa86a0764d55178d31d7b1104e60ce2be28765673d92686eec85ddf66d415c930a6f1655b0bf82b97d1c4b178b2a741947bde976807c15093cc64ab2c3e0d2ec6049bbbbf1d6eb900d23104aaa5730e9be4d861db3a5603a0e9dc4865d7194e63e066bd62213bf3dbc8d931745de501526905833bde9f2cc11b4510ebe20a6edc4c4e592b68737376d6c019afcf2f90af5767ecf5ea9f933e6f1a7bb2380394b8f313da6f1c1dd8a26534c7cc4f9ca26af0e2bdb2eb5c0616651f9f1f07c5342d03a17f46da60a619bf724994e67a6306b2a8a2b6a97bdf63e60dd93e0ed8b71198d33541d0924efbcfb7add40c4ca7ff8962b949b2af11a375db43109ae3ebefcfaf1fafc56d5701a99454a50ed30c4b187afc4b0c4da140f4fecc92758d6e607e9a67b489a83b56e47946a4a971724bdbb3ab859dad47ff7cfb5ebcef85ea4aadc5a85dd0ec942417f4737dd3d149cff7b14e85000dab87a00383d121c54684312570b74447685f5c6786c776735694240e16676d31d0a83e45220ffe27021f78c6fa815740ef1d38a221696e1f84277176de809e2ada3785877e08a59fb42dbc51917adf7f0a773175343448f2c8b655e71c5355c3af0ebc7f9bab160994e9649b0d6f49e7a70cc0f9fc47632aa9cac781edf21584798e9b6da1475100c52e1db3371d15bba83e1585d4459cdda1029e81d1bfbababfaeef052fb8fbd9ce0048d64ca0ac730f17fd3c55348fae5af57ded5c3d45e92e0d7d137325532f03f33cdb66afcc667ca579d07d60ee3da5e0f6043350e33bcb49767b4f3dc31477943c4c143d25b7f4090c0b6de6a737ee37fd91cef806f5fd14e49f55b1f83fddcc3c16ec6546e1f85929787e88f0458ff046abcd9902e28036ad1240b2e66e3c3038cd848a90238ce02fdea2153f9755a98778e6231038be9bee79ec999c7e3df6967906ba9eff7c8a723d44353644236be87d3d82c307d45bc9c4ef9dbd9236726188d7ab8caa4fe03a3e5797c8f18db7462377421a80b1742bc10941013b9c08631dc26b41738d69cfa8582de91ed8e64e5aa299658caa02a9fd7d6d573f93b3115394aaa272f4a9c6ad45b0084c261a542fa7d6aff1cb7b68ea7dbeef21f8dd0ef57a21f8da71d8005cc09625353d81592ab582a7cdee2eb32358fde1395c4a8135fe20f26ad5be1b3a45d2d9a43690c88a7c6dc6411b46207f0226f0349457d490fc2bb69ae091386d2cfe5e636fcb2bb04ea12ea52d78b45fc23f1e392a2bb35fd9f0b102467dfdee40c07f601c2c08513c81afa4817a1bcd471ac32d70cadba72d885593d47ade194d21e7c629623b531841807ca10d1bb0c9c26ab2fa1230169a9533b64c615cbf8fde894fe0cde19fd937f63eb03ff93e0cb54bd3c2a28ed6821ea8f4e9ea9c8da447d0e3a95af9deef1e596bd37edeedb776513a0dc524afcab8606cb6a18e75329043a14d0dffb97622740df6e42339f3c1b80c0343fe986615f581fa512f9a9080ed7c7ce55ebe3512263020d86a95e7d896e39e6608e60fcb6378c4afbee283fb24a9d1221567a597cd71b3340b9bb77d2c8d14aaed6cf090892f7281b4d1adf0d362286d0f6745ffcadfeb6270506563e8f942fa969515ac69c19225428f1430ef8bab44534eaf00f3c30820e40b6e986ab3f8c60daddc47776069f627f26e0ebd7f958adc116136d7fa17fcd9b3067cda59daaaf435e68170fd3bf1ca8a1c89388f6ed59bc8797f4da7e9d85857347abdc51d40db41d82a746def1e13660bf6bd287846eb3745e040f65be45ae2a5b94e76930d73b13c622a5238f733cff3fe6a2a39f2b2ba08b3584499d0f89e302ede8f3b3f79f761a806d72cd0ee89787a140c458bd4b1c02f310482746eb04b83a69ec9d6973011a5e536a699792b2ccacd73baaf9cca402d8620a8caf8544cd81bfa11ecbc413e05943b0ceb6ac60d8abd1463f9d975a6b50d092b2e66729e4d0e5b5453b286b56026da88c8b7ed4543ba4828e9555dc6eb65675fa92335f5677f678e322ba97d9f7b5d4a76126aaca4ac475aa7dedb7aad58ae694473b248036641395ab6fbe6c06aa1d710380c03650fec9ba2595fd296e757d337b2e2cffc7995da8523b129e067098394ced3f20c4274d8b46ceb5352e0b3cc8c6ab025477eaf10d32e4ecf2fe05436cf214d3c56eb20a4eb0f38591069e5a62c2d0dd21da2d509e11982d59891baa0ffe7208f18fca3ec0e475fc40fddf79374f57f8b8c99c755d00d48ed2460f1088095e7183e6bf3eeda6e8adc15328c4599c7736359b14212d3b9249633788640a6dc50f8699f805e35f12118a103d6a58196223c87064ebb08407e413797c4c78a13391b643f176f9edeea25ca52221dd00a9d52c19976e8aca7cae8e4f30e74ca61a6964fbae13be8ad040091223ecef600eb8757722fc426b70329d65110bd3c02737d6aa462f6b159f802afd4b5945652a6a82d0e4268f4ba3d3a10d363550fe6058720a402f7a6ebf79efdcee312ddab547d2bbc46c7eea78d6838f8ee7f005a102df2dcb58fdc42d9353e8013d98e884230bcc7464e9ed3990a88fb695b43e98963f5b410f277db4e59eb87742420f6fdc7689265816827ba535f70df22db1b7cb5225b3c7be7b27ffaac0d6fde4425c90e9080214a5fb46ffff1963ee379b9c714d3a0aa1b78e6483e5928637b2005ba6451d599818e962255ba1a9c63e2897a8064e31582472babbab7393caeea67b060aacf4b0209bf0546d77ee9085339245e08cfd8cb7a0db4108c6a8648dde5489146b779221b24c9ea3a61080763633ce8b5632540b9d787b70697948edb1a37fb2f7ce0cf801fd942d978685920c14241f92116dba98f06230225f0e790f6b40e4f3fb4e6cf2ebd35cca6f6a9dfc485b133b38ba2a222950c5cb4b647e80f260aef9dcadee67956307fda6a001eed0006649e39928f8426202c66406ca57a8b474fd9c3f5d26741f6c5f941049778a537ea3a66d16eba367e9f6cdcf37741a253c07b55167b204ce94bebd2dfb1618f26192a9bf2ee5960dd5305aefb5cde68c606c0002b203d3219c0e59e01baf5bd8642bc29e1af994b340fd44b07e8e3057596f167ebeb899c1d6eba7435c143d8eba8cb67217969b7e32f0b3aba06fd6006f3f8c314b0c781c8d964d6eb85c3958c53b5d01909aacc48ec696151d9101f053fbfff7478dd0c4dde29ecf52e83582db96d58f07573b8740e68bc4a5d5c0cd4e0c2909ec52d2b465300d627c36b8ccb43bab45715ed811adca154f83889ff65b70a9ae7b94b7a4fa42d469204582aca3147561a2cf746e65539d670ab5ba462dd80dbbf4d66803e8e072a34c5f37712e0af937d26afc8787baff0251808afd889a24bc225df78b1c5dbef828b84d8449dbfd618dcc319bc227b86c07123fedcd3c3c0e31bcac2ce86ee20475644079efd89cf46874941226244f0d8f3b3d753880b2da5596a630e6d6933e874f07a9260149042b2d465f1fed39ed9b0ea887005f5b8ec16e127ef46a3ecbcb1a2874af6e70bef8957138934055db58681f48bfc759626708ea75a4c2c43e0c528f6c5f9221986efffc42fb74b900fcfcaf70ff263690ac0bf81bbadb081600ac5d8da67ce0fc5d52454a9bed6c05a712594fa4049934edbb72c7ea9a7da1acbd99abdab8b4cd961b04034496e1dc81435ace5f2f8c0038d8de2bebae5b96af84b436b3d3360a013a912a3abe0c655ab8db963853a8aaa368f09de5dfdd482ff15c8a6d457685cb35860d9ee10a2c1a7dc365ceecbf87e3dfcdae6f2438ebdedc3b6f076a4ffe89f08fc69f9e2d5998a9855339c733162f07dfe8adebcd62d9b2358feaeae66c23326060502b0d12236b4de0b0e5ddc47cb4d362b1e1148c0c2e4ca29119651f51bac41b38991e233c952e4de28b4bd2a9854d56cfca9d0cc192999b05276fb2074d6d4cda87609097ef7d7507bbf8e737cbc4482b878eaa4ff5e374037a731c84c84ca8f44fd022151e8690e7d4e9ec869bc876d31346b3b2d9b5748d96ff0af968341dad9c3feef777d05c31fd79936c3ffb27a64a3f2652d49a621f39d327c114ea94a3e5525711012f02513b5940a94a554790487bbba215374819f3805f5f1a80cc07af8c9774acdfe7ec33877fcd0780bfab56148f91ebfbd888fd90132e8cd0cda9b6362dd26d1d3956237442b0be6a14a263eec9488f8f73c7bcab199b8b133616f0c399bba16a863fefc1412522b0c79f50fa1f4fdf4e0de4a65b83cdf8e5a6b260325274e04a4791acb2549de6104ad1504e25696282e94113cd1cc8389a9b6c5d47cccfd4bbbfeb8317de1355c389b31d11a503a2c65853aa2d3bf6f854710c025acb8fd24d83223fa61ca72be5242227c24bb1fd861e429c59071ca6f4cfe9bc9841ee0cd55045c9e205330d1de772923d2227d040f68ba2259ad8882e391493387c541851db66d0b954fcfd225f24dec8545b21d244057179820868d50d9cc43ba314ce15fd05f934e6973d4f9c6a87be836933563caa61af889afc4ab19af039e167a4b9bf199867cb200d7ec234b6801fcbc631f430434f1aa875660eb02809ffe4fdfda5c10b144d2015bde93996beafe51e45f7de0da63d100ee59872db90151471a10c1e0fc88e12d4fe169e3965a1e3dbd8f42c76b3d3306a8549bab11128ffead24ceaa7bba7a619cc53d7eb6d00cae7bd63b519ee38f5965db07d6a9189616b313167c1288a3c60e1729041aa12c32a827d51657d967e3333c650ec835c3ed93d39147b649fdeee2b6c2b20f1b9039a51182cb1cb9240a03a3778abf151ea1768d9a763740a65a483cb391e54e4062a59e3d243f8124bdc58e23d204f1206d36654e8c89a5a4b7e0d99b4ca9f9e5e6b3bf50e1dcf8bd69906afa3773e73c50163d2e579adbfcee2789ca84e9e0677c98b2be84f7706e41efddea0aa7a9e14954fca4958bf9a75d746da0a5820929696283778f8bceccaef098f696c8eaa163fa29b78983c3cef7cf863e41e825b7a349472734d9ca1c026cee806f518cd7afd80817f038b33a2e157c12a40e3bd495ca0361449c87c05ff752d917f3e0653232cfdd16b7acc2e0c9b722047417d45db6f9f8fbf631ff51ebf8e15aa88a43291ff913343666a8f17a89c4526a534abe5f4c8619e079ea2471a454d55d06d0794a1126fae7ea5db01d6617c51b0eac962d73884d63c89f0c4d692462538843639c74a903b8a864e7037a41340aeba2addfd5d0c565ec570009da63b465cf79b33981c377d29f963931ae20b6302bf31ca98733e32fcd6b5f169b714dd5ad8f0fe2009507766bf33a01a1e42ca1d0e46c4ed5e9f7dc80393600352ac9183775ca805f39c07e877aa8e9782a30aaab97551bc9d6dd7bc8bbbd523c2e94d08fe5cbfbdb284534f1be586b7886f38d7b728ef5081d7c9b62556f63543d0a1e5514894fab5ac6354bee32bd711d9ef0a0ede44fb63a17a8d0c729196fd64dc9472b48ce01e894282028135298f1060d9b76adbd86e56f17bf4d5b81bdb6ccb09882c4b434fc5b98505d9f9d6932ccfec7ddc700803ce974278028f95a50da88cbf19183debadcafe8ee3e6642d61dcd31c5d33af627b912c55b0bb803da04ed1800e97cd48634f3e68f4107fbcd68e1d355cbb97a5268dcb6c11a2d98a7206d279bbd49fc308a90d1eb9e73cf6083c9ece169608ff5312f156a89660b0990af0402ef661a532efbafa73b3e1057e7542f74d1d47b13b89f6e091bba3c3ebb1498c7672ebf68620f78edd4ff87519307f6d40452c54951c005483e0130a470b7190b89dd9a8c90a5ae0c5a3338af1524c940b290434fd5a300179305e905b48b2b686fef09c1a0610c78a2e57df05cc44e0b3c56451cd426ce447a54586cb45a981c835760a12a5065fd","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"5bff68f06ab680c994ea76941c40f8ef"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
