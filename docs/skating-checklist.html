<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Claude Artifact</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Claude Artifact</p>
                        <p>Enter the password to view this artifact.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4d366e1d0e0507eb8e2c246efecb6e3fcf824e19732be0d5c632f3ba75b61fe5a6c183d5095013662b36058974d26974725542653590ff6fa758daf3f6e3512c9871c46141ccd2a1b96c2f54dc4aa64d8cee66cbc35ecfe1bd1ccb7dd60c08d573f94f4eb8a7f41b9ec7b7ad5af9df3f8bfca73a9419f31ab82555859e119d966895559d42d4c54a5d7957e307d2b0edbcd27de5054cb3c8a1ef19a21672f677699cf7bb8a3ed739ba3736ab9a553812ea7792c2d2fc01a24ce601f3c1b3f2b4c7f84e144dbe2cf60e2a32a7847f2f064c12faeb632c908249d11066f274a9c26bbc4bcbc66db9c08acefaaf7e769a01173116365c996d63efd49322b67204173887cb2bc2ca59dd9ea2179efd8cac5cfd5bab5c471a3bb163beef778988d8b0ff4aca8efc73f800a85e48ae404134b7b4a5f69adbf118312535019f6caa7b4fe72a13fc586d9a77cd69c015acfa8b6307397aab15d0f992d947d4990a8604b8e9659a800544195ce532fad0570e4417ef251f365e4d53befb795121fd2f215910220063f6a2ba47ca5f0998af5365fa57e6fc49654b0104c3aec4ddb9657fa7c0e509a4850f85c81becaaa7c51eea701022e7e6ac3710b751be1c37b356cad5445d45d55f8446e5160067a82d4c01616a5b976fb84a565472ed3dbf89cf9800b99cf24a1c84bf965cbc1ee7aea467c003b96d988fbf5be9d5c99b9dd9bcd9327fe830676fd631fb4a0daf4ad017b1929e752335062aa5e93c30f94d625892ca0da4a4d1a866a0ff36ba4345c16a29d06ff2b8127011c781004b5c94d96667414a060433b539e763cea9a8e5c2d67cd9c89d30aa52e617290837baeea02ce953b5921557df2b2f970e853ed9af754b6b89aca400e3a05d3f317c2630a7ef9c0ba120a110f8f465b94f192ca10c6e26bdf5345eb7086a3c7ae2e2a4bce3d829aea0b3b012ae9b9fbd666f982d9af4914b58360d679c419434f05beb933baae5233c5650842e2f463f3dfb7dfa54ebf05756b4e3ffc0807adebe5cab192a316b26bc3249a3809e3cd940097af26a902afac6f34d19d589fdb93823f659b86ab593a9b3c1d93bbf061dfc7751a44686a4898b20cfb42f4d2f25430cffea228bb12164c3ac61b8716fab9750fec65ecc676d65ea9e39a954dcc87215b4b1ddef58abe3cd431696be57fb2522c697487670626beb782104e1f358dc92c52b4c38e58665cb9e0ff8e165c69429e40f5f68bd5cbcda17fee9ebdd77e4207ef810f5714d457c8a05a8b77326a6e09441051a2184128580b8ea41cbc7208effeac00061b55618eb10a3b9f7dedcada11bb2c848c209bfd413ab96cf36323ff4a27fd81869f588d4c2927412845bb094806cd346eedf2f5a1ad317dd4f15e3ac04b2af4f234c7ffe5fdb467eb15dcdd4dee1d619e413c50be50f5b3ca683f2e955f54eb0faef117e07c11a457b83834441b51c43e6dcb515681cc0ae05c7a1315e2744542a249056d29a3c2efd624685b94ce555042963ed4f1a5ee0aa90c6aa1387c56232efd4c9721b946e6b90ddfb62b4e3068705695c7d8370c8b34c20a8717a35e8a5b9add1047cedab40a16cb69dbb884e12a16c57778f61b8fd9db52a0df55c2e04689b188b658c4be180e82e1caa0cdb223bc41c679cba8c1acbdd3f7a3fba6c83b3cb5bb2ce37928c9dd8ce8ac37ee56c6e751791e2c14ea75b116bf71cd2ef0b84f10755eab5205fce7632ffc0ce353cf236c682b54d324267d632759dd1a3626688a1bba21052250617949c61284b381b8dcd2eaed52d3754948a70c131fa5e26fb3471b21ef8ae7045fd2ba3fccbbb9fe1cb02ad0d1ed3fa1225da7cf2b885e4a8051f2bbfb66f08c0f044e76e7537e25d70ead156c97c4a090abc0e3621cf80e4660a56559d2b6f826bcef09750d2c6a32ae5a936585454e449dc999e8c8d390485292213ee41dbe93c2cb520f2474652ab31c459c72834003da73fa78edf4cc7d878052a662f75b2fd6e2548df2b44c6e3cfcacfa47b96ae7ba319170113b0ca602bc2441eff0d1da85537294cc1f491f048d8c58859d6652dc5c0c0566b98db075a8a88202438b32f0196203170ae4fc8170c3bf55bce4e0b2bf18f9981350ba4c1428f40aca51dbd7d65216fadd5d25865a195f925b49c1cc0840ff41dcb2b7e9dfa903783a94e58163d9a49efd1de084f732cba3e9bb986f8bfde02618798b94e703230315c870321d59cd7edeb54c678a12f8d15574634a8e7988fd4fa97e750d251aa1f63406f79eea84258602e31a9aeb6a62b0ef227bcb2e0dc5c4c2980fc90a4eb76e555a240c163f39669e9c06911eae6def1724813d6f6464f60627045187c79a007fa2290e7d4b33353a97d8f29d8973039967fff80cd713b6bbb8e3909fddca2ce1d916b709796220970a4affb4f0ddbb59f3648479d6a3445d0a21564e18efd8ef872a7e87602fa8ed9e425bde0b902e5da5bb042d1026cdae615a437350c740504e20be59837e2e5f2bf998a30d54cc9524f32043cb48967ab4f7756317d27c33b7e970cf3d8065454d160de4a4575e474f4ef8aee5194c3d922a8c4ec3da994141436751da138d61a8f8764e9b3b11d64b055bb928fe26b6bcac2f1c875a2e30462d00c29f4c0b235738c7dfc76ed8050cb060905ae6e124b7520b25be261f2712b2ec46dd89bb989cdbf8f9b275a011967a8b8d5d468713d1023276e9d1d49ccf66d0eb83f6f77ecc126966b451eb34e0feea6142737d2283eed5e7618f27f28979e5300f70a026a8678bd7935d88b9fdfcf9e39892d868417bc393b7b2170d97097b283651413d5d8c946972b7f90400be4c7483f14e79aaa7189bb35801502b5a4d752667fe9830bf7bbfc5a5eed3803a096951640bbcb0f209e780b10c87b92331c425544cc08403b27aadcb2ca9708f562377f8de3d820471118231fc93fed2fbf3b5f06da2eeaa2794b3a873f8ef980a6505c93c2c1fa24540b497d77c564f2a5eb3445bfdac667dc3c6046c1cd27f8a219e08a216953bd377d1e71c35e65fcf6231c23e0d323edc4d74815c7deb2b45ac74bdaf367b5ce28544409031a56d3e19bb45c91941121cd022a9c981ddc41f3310f42b500079fc218e7045517df5e00d34ad1a6b149413f5252f77aba19f46a52cc94a20ed320de5dea76755af37354109ad3640b18888c8e52324a71a87287c3981463e9ce3a038c7b064bd2ac5c4a89eec2516693d4cd9f013dee43d1f3bf4506d1388692ba0a4879a69ce5d9e1031337746e62e38f5a76bf2e0877e0bb8018b2af9b3c635e9e1b9c929b2afb723952e48bebfb52d876e479bc1e000a9f89c03dd1002ed974a168e1fc936f0812ed5a1a0aadd11ad7dcc3a137bdda1ef333fc870b554c90997269729f102ebe387c19eb37265a0cdb4e27c728ec5aaa61e27c975e2e4e7c170252909a2ab51bf75872d92e8e72be6066bb1ec0e75090e2a9fa75a778807b954d5caa586828914ee8e6049252970ac085f41d1001c7ab00f35d743e7906f256f1d7d3fe35b079334f0e8726d8410c1b59b05473c88a15427f38134cd5cfefc240d34bbd8a382b27dfaa8146739716ba9d24d412b30cd3dd1f0cee992d35db2524faba3713a5eda11a12a4dcb9ca81b67d33e0975250dbac3c5aeeaf0aa5c68ff06723d4d1214127445816b13ea8d5af397e94594133a9dae9dac4039764ce7769b2e7c81133890a1f5a909697b1c0333e79ea71083a9adbda74993a0aa5e9167efbd8f10bafd7b224a6d2b8feb2d1aa41df04606142a2a4d40198d7506b5a913a4b74707eb9259e9c3b0311db63d10068cbb5e0f591dc6f2a1c6c2a3cee11e516702519c14d543a207442b5de8f7b48262909873d4b76eb789adce0b3e325915bf8499f70a4cb0d5fc321c1d0705a14494e71277934868ef06099fa00763f8fb3254898c2b5089c9e9b88ad7175c8316cfc2d4d8aeca62e3f1191694e6b11d90e1fe7f568086ef8489e15673da2ff15a604598ed96b29e9c098243abf566e10e7ebc928af7de3a867a687583411f9abbae29abc3bddf434e51ef1cf9d87319a51219a56eb294de75358987816e8c3aec3c588c28235bb258da03fca967694f7a706922ebfea7486619737e054a388eb20e8faa8b78e918aaf4c25c9c9317f6b8c2e6b953b31bac54a09c10f5d71826286b15a9824680d660443d138791e48ad33125113803201affbcf6f8175f7851f3c009d440a74a367785d88e33ccfb98cbbdf01b8b8c14c5defa0c6090305e58b47d8f2536b4a393abd7737ca2e4f601b030a1d09af1ab6f2e1db646328aaa0574a9d035e7c2d8b253c0daa63d31793e01fe21ac04ff11268a8b29177b1b5de5e3c79a21085180fff9e0bb0c5c2bb3c631de017db11098683e8c160925a092d8074e2a16dc82d94d608341d1b44d5e848e5d4f5b884784e351b5cdff29cf9dd7db3eda027814f7e00ed1910e62e8728ce7b560fe35ad74f5e8708f542bdfd36c5ea98bac4a3581cf792ade6836c72f767787e927ffadc5dd2b65db8ea16157e4e2bdc222307d92cd16c5daea4a64e6f4bbd4f4ce4ff3a645058003bdc43560650549964f5fd1bf186b667752d550c798a95fbe3f0fc73c38e097a01207b0b770e184fe2ac6ced145a74552e41dda4871b26f4ca3e88c1610a1d91cdf9f96dba636ca4facd69cbfa72ffbdd50669e06b481c2115fac6432df19b759a84ed8ec844db3edd7260fc57027dc7898308260924db95e5284cc0827318da963ca339981bfb424941abee7425c00c4c1e301ff8e72566ff29455fe35c7ac31930e6896fc52df935e3e91e544b878614ea6cf44dd01820f6803d63f133be063cd4783432fbf0cd1ea232fc0ec655969ae66ebe94398caba975811e9a77664ad0a4e2ca82c097f2a017c2ae958beb54f4d09d46c7cd9e0334155dd51ec08fd437b79c66c030c92f0137d920728dfe4c03e8aa42a0ed48e8c398ca096599fcbc6e0358c90f27984c140a39fc3c7050b6800493d53013a65f184933acd117cb941df31109771d67d7cae779c7c56ca2ca96c0763ea3aceb7206c67404b66ce6d91bb4b78081d19c619a34094d59f6f99ba4d6364be82260c99e8bd5877e1b6c0c6225ba5a6891fba48ce657047d32709c04e623f7b4409a66b05bddfa28ae5b1ffe0996cdb3164fb4eadbf2fb2b27a425d9d1305012d1ce1d99fd0bc55c9d4e68872736898fe8ed730a73160829c47069159397b88b4a877fd108531eea8cd3d5046789962ccff79dbd0da700ce1ffedc5a386676a121153db68c053a5802cfe6c02abb27d74b49103ede50114b5aeaba136c5850cb6f4550c67e9f6fdb21ce7768edb71bdf03967be17f7f58dbcd3e193d1abe3f6230e7cbb826eb877eed8643df6f7d4da3fe80f6b40190ec2127376799e5e804081da4ed755053c60459e028e8769e4c3a25f69243446f0e075ba218eed0c9c3b4dbd26f366c33f0b027805af4bc7dfa04a968e7babb361b6b5a51c72fb88fff317afa7cbc1bf52b3603f877c9185c56f6ec1304913dd3275e3c67d22add0203ae774392774a3d1be8c1fde4e390b20b0d7ae0357bf748848869405ade279fe64bea44a596d10b622202c3b54276d2ff8586c6ded4a2a330be115a15b05918f177aa2364c6c7e543e9f1341536127325b9150d4e4d4e7d2d3ff5c5f3e27ea7660926501f3e5aaf93a6d07bc712d940bdf1d02e61c68d15b149bd9eccb8607af36fbde3bdc479c820627dddfddc285736606d55ef5575b1d896b5f59021e0a7d52821d72fc56ab00d55c90b3190ff2a115feb581919c4e57392bfbc3e3c6fd2d87164ca588ef8c2698b09f79e58c96df2d5ea306ec2c622f679303b45345e0be3dd39849d69e220817b5d7a2e5f9f59952aa0b0dc642091e50a5e26675a22f9d803962a9dc8a376590358e8cd89dec4cbe6630a3c79cd79609a0bf4b3d1cbd8157d72a9fb6b60b5a109bdbd7ad8f59017df014e53504a2d28cfdfb9d38f1b8838e09c0d81295c2a6d8c05ba6f01cb3c532ec510c33b5a9603b7d1461f8f4d5baa242105635b910b227b49ce6a821801a85397e346d650d5d0382cf76beb7abc17af0a91bfad74452303ba7fb6fa4f9f0cf498bccd06d83eee8c278ee2e0d0365e029605228cb6b15094d5db60e6b9304b98cb4b9a0fa48fcbe5130872217c679c34336b5f4e5055114c6319062f7f3046bc3706d4686325e0471d2003040f39a955ca38c3ebb4128bc207d4a73a8df4d806547b4fe073ef726564dad5f5dd4dce16849be96d4efdf06f97d6a72ebdfd6aea3e3d44c44c7a3a75bbd2c27bfdb3623a97ff8387737bd142eff2e855b6b55cef6d57c22dff90c6affd6857bd1d2a9ca60782df1d52cd0d6b3aa3c4bb74ce297ed881d7e234fc1ef78c8a6273829a4586e14b4c9cbe7cc06203c1800ef4887af57bef650e45451af288939df71e591b9049d222ecfa2ca28260d6ae25171dc4d499d56efa71440cc511d041450140c6b260919afdbce7de563cefb3c2dfe3f1ebcb629234a8bc14952feb2ca919f8dea76d0ee2b371288f0a8eb10f60fab2b585f558ba844f6d57b7131756db84e607ea6e1df17bff035df621392474711c8054100fd6af6608437fa3a43ca7cbfb0e0eff102a51dd48751cc04a7eaabb6fb3a1119c1d8924022b6297bcea263d72d6b0a34d8e3a7dd4d985a33acac3696284185e5d13781625d8d247ac7d43f1508cae04e89dc28f63592a254ce49effecc8e983bb38dc28fbc4e7e9995de591b26c3465eca0f79440c21ea22bc161b666ab7a8daca19ecca131eb8bbcc9ab6a0dc986434b9da3136ad3b974361e49f28a7520d025fb379f41edb0e2195a508304c87f896c7c25659afd6f6fc855910e64bb8a81bf5d787d164b624d646a62af283bf2b60d335f58643190d90903a06da6c0bd7b422ac6846f55b23bafef0720dbcbb45e03837316b6e7ce7b2b1e9728176eceb3a454306006da06e8d6d82f3a56df24fff922fa91fcbd5b8d5a078175af619cf3e50e245676c2f7ac4932cdcd395143095b8e8d83e7572d3a3cc0b29e76c8927776a06f53e2a4a2faa476e50557e53779bc1b74757d44eeec20a7e86fb527132b69c997377a3332d35c5b1e151082fa53a3ab052dc8b66cdfa85243e700b22579fea37ec642b64f1ec79be779946f1ff5b3569bf955f0b1c1e0eae365c224991cf7ffd5a8571487bea01b1c5e29e165968d744ea6be78fe44183e4bac32f1d3afffc9116164dbeff5b1bea4156ca228f0bd57ba121a56832b3bc9f05cf48140efa7e7c6f3cd8db4d3bacdb8285dd899cf6b7a058d50610f5d9d89051b6ab37f3aad51b1adc30a69edf0c87445c780e0f4635fb78696a9ff18026669e6643551c96ecf99eb301dc92deb9a3c87525c12f42a79bffe1bfdb1ff6d96a9cace4e82dd9746fe232b60837d250e1980b4d94d499c0d077d3219db5dd4cf0f7f7e4ba843a210a5f5d1f76944322e427be9244c3d509a2e50344767ee3f77d78206dc04c69435452301d2786e4d0af436d8a80f97a84c8a12c0bb6d81b3c8301a5600476ad97d0b447c63e023a6b939f148762a9aa4b3ff69f936bd37e9bf74ed3a1b228328869ab95548b69dc60f473e26125e8b1c234494346d8e2f0cf79a6bdd82ad949e658b56a062cf64b918218bbda4e4c44520a733179b82040e1244c8290f138a81a9c2fd0b86abe6a9d58ab5c903a1b4fc1e7e7be75b54c78e0bcb3f5b665ec2b02742072c816ac4d3da977fbb6759ab4e3873166c430e1d101584f104fe2f9cf8750cc88ba062599e57d72655245ad414e7a3f4932cd728e9b5456cb081c9e441d4372de69b62d9543697da78c60315d859b96db32630a26554c3235a66d7d5b4659de7b5562eff6544db791585a2456de4cdc3382197ae203c18ac7b18738b47671740b707f1fd2d33b75b4539ade15a786f2fc4a6d0bd08b4c247462a5b3ed1d4dfa6480833e312d906c5e8c3ec97143da78167ad1425cd0e5e2eed638752be884b57339e775ce1f7fcf60ca73bb335f7a61260e67377f1367e25e14c9b592e57f2013564a85c764ec16f7de3316f5097c4461f8a7f59757516bb1ee2f0ad3bc3b82f02868dac7023f705b07ee8ea1cf12a55a60adff30ecb079171591adb9454d0c466a6ad8babd5394a42e64aa4290e02e2fd59564157d9dec19c255d01690d7e4a0e2413dd41feebdfcae134df99fa12ac4c9225bf3800d6dacb3a258a81b69985479895bb195f16193178f86d4df32d0941c4ac5009019f7e3c5f579f8d2c7dfd895c471967ccf1e584569c80e6ca75e0fb8df5ee8dc3b13c93b8dfb2c2d6f3587de9c909d8d00f9c93f6506a3692ab43ab6126d6af9e20b84257d444fdde0d86265931efb8eecffaaee77ee796a6fc171b25516e48b6d269b93e9d96f2ea3528fc0af1e3bb45d689bd367cb180c620734fe86e911558a92a03c29bac21f25a6ac94ff26ed04f83c229a8bd7decc0e0ce9fbe3e3681c24c00ee92d9a1a0294e80f845619f5704ca07ac799133f1ba13217d578b15943e782ec421053acc7ca0389c77e5a6e1f962a9209d4bf8f646c9475efe10b3df856c9c85d8873faeaf181e60516779d4a7a2c10e70bfce713b754f6ad911dc90f956090f4457dd785784825b86dadc5ca03e57f8a5be1d4a7313767f21abbe941186f032594ce131b0a201207ef562c6cce9e39067fb8e1ad088b453cc632f82554f848cdca254a209ae277ebef3bef7f4502668655caec94abefa57b5717e79be2bd2a79cdf277ffd515c1492372fbdbbba35d729112a1ecc89ed2f3aa9df76b9a6858b60308faeda80a08acb101b557c1c4cec16e020423d511cde929e54abbe94b674249b881a42da863fe6bb856ae6ff2c186ddaa424f4a61ae53ee90c392f6c4ba6ae7653e3bdb56518a0c7337f8cab65b7a73180ac61eaf76a16d6c9a85a76961d37469439d91d716a36e8f3e8e13785e5c0fb937e860120f037fe6038f85365846484f8f9e214240890c19d47c733ff9dca14bd3f9dd2df3934c166d70aa376e4931e2b47bc7f0fd13a48942f2cd64c790d979f24270c61884eb078399c6936a767b14e368193f71b8b8c0efe334546a032cb318dadea36bb123ab5effa4cdfdb2e34e40eb67e732d7ec8abd51e815d91d2dd9e842195344fc6bba3f756181cea9197c39c61371a6d895b9184b04850b4187c722cde134c86bc3f25b8b31c692b476b70f3233509599cdf65120b5197c11503cedbb292cce12ffa0f4f70106db521d4439fe82ee6604c0621ca3add8f6ed88e6a039c45e4304dfe4101184ef48ca8b64492c4ffc8d4c030924f949f8ec054cb81872a1d31b5ab2cb94846be1678a4610f28a6d0aa4abda92b62a9394f885d205c01ab33a14a0b5267b6ea8842dba278f7a97c762f5ce645630c20b642a90564b4948f13309e68d90b76781e73328943243c7bd5ff21da9f71b7bac738cff3105fb811ae1c90bd2ba822ed296de0cbb2f6206b254aeec477a563357219ac6bedaf032f785ebd53d2f8c0df2bdcdc81108481626f920de41329d448be5019b96f60cc11f17909e80541ef466ec4c600080efb204d1187332d8131616d58c9c2edd14b57c045aca5f3826a9ad1617b110a886e8457997c60e2889c7fa4af7b7e10dd5cac5bc182667f84707b2948718ea12702d41d4acba97459ce2afc34c1c8bb442fcfc54862ef75244aca8d802a0bab2d99d875590f1a88377e43e0cf24531ede1d36f4f05c518b17b2bb6fe5deb7a8bda5a7b8ba430bdeb3a74406c2091abbb31422e5fdb5e7a91d20f9812485ca386df11137a981748b1b482c62d559399383df4e85db2c7e0392a94c3f7395b52fdc8b6a6f5b324cd5e9fae9c7cd78f02dd33239ab6783c185329a361f8f272612d0d254ddb92255db7962bac25779b89b5c5eca85925d1f246c1daf69e215a8d828e9692f9a3eb66095d81b344af2b17e34f1becd1540da46375e512bad96432b912c507cf9b4fbd906bfbe210ebbf6e451f72ee5cbc604be8a568581a3a74e48fa0d4fd74a44eff106c39a22449cf002cebd7b0e9a155080b29dd7154c2252af4706e731c58d478723a8d2743acd4e636414dbe3f67d5b3e7bd4f19d0ec41d099733b3dc954b544a6d35fe7bdf34e100e2fdf9372f62507d0149e2d7d2bc145cd30a656430edfe44e46c5d7a65163f7f28e5de4106c0c4f1b99bc751d8292401b449d23522c60c85a02e2a63533b88af9040c3713ee0da245267b29f454f163847c3a629e669fbf2aaa5398fc83f64f079d7d830060d7419a7aad0ec784690499e59c54733ff0fcedcab1202d496a9a3afe308291f272d4a0459124806fcadd2a669b7e7030f584e7dd8eb0187b9a5ddeb980a2ad470427ee8c81d209361997e37437b07960cf3abf28efa980486b89af8b5fdfafabdd9249e6acd218569cf75589e28fbdfb44d57d3fc8ba4420179c9f39c4d9cf0460f09ac173aa81e2c97df1473392b2ba19179bff322742c556d74e1aa1a2d5ba3b12e0b7f90b99c1c5265fc3b545e21543c848507b565917ad50b0670a102d5b6c61405ac6485a75115a670529e8bdeed1f6b1dc79bcd135a2c35a83acdd98415ffcdea12ab129c6488fd2d40550bc57065c4c77f440abf5a84049871d8214645a49fe6742865273b20c3c8a3cd0d893659c7afbe225dc6a7ef3e529c7818ab9df6258d18b6e19690b305aa125bc2b23bcff4cce5f09e34f60f5a98e9785f2710d47970ae82bb1f9ccede7892ae0af6e16ec48226f893dceffd5f14762bc03024972e81d154b1ed941ffa6cde2ba534b2b78cc64fcc6a30775d5502cde16c353d4e551fd4177a767d1acb61a2defc3e922cf03494835aaa96a1a93c82688bafbdcce9c3fa71153da27b8f9e966bee846b6872827ee3d892650b4cdf77fb4d564554118fabf627135cb9a7ecd6232a264be6c9bb2baa70f41a084fe445912d22ceedd17c5f4aedf1e13521810788f2f6c90a5daba058484cba1cba8e04a06a6252fbec052275389c021820dc68a2b0e4aeac1bffc05c62335e659758180ed8c77357e059f2b024afc8842472bdca8f814d0e33407e232910c0694e9e75700148e2c36783665a4fe31c70e80469a8eb444f7ee44907b2b5dc1b2329b348c465ecc3fbd217e8d0547119cf71f83bcb13b195500ad2f02cf0a03d986215712ee35d60b5a81be9b49ecfa221ef73b566785bddaad81d4d6f6fe86a7d1a0b35d41ae0665c39000491604a28563398d198a77f2e06aaf7908abc6706d805db95dd15dd90f227b33c633c8e6cec514fd80b508bc0335a37914726902bb3adc451ad1bd084a1a876c7afd560af5247dbc8a872afc92095de4ec26f050e7cb5eab50e5c35362deca73b925cbd2b2f7a9389c3320ae445f219c3d89e020402fd3b5b5b8823d70871da5836501af1b882f9d863cfc7d18448be828d378718fa43fe64649aa301add3bf5af8b7d13fe18c415fb81eaa48f2b5c3512f5bb80f41248dc3150904293ba18418244cb2b3addd2c0705b5f7450cabfe386113aa693415347b8feb7ff6c63cb1d67d8214760e7c0e7e28be61596f5813d3254e8772b4ea6efedcfff7124ef86e65052c796048c6a786e5b92aee7fadb3e90e5e94596168fb99db33db7eb075a8085efa98e88d30a2ec5f8c2aa4f99dda714e0c0c3acaf5d0b06b00c8ae00634dd444a6c1e1821d17e3e2f8f2efa16a45d74c76656dc9349c8a83715dbf3cd3c683fe227de89a4ead6b29e38c0bc37e78e77c3b1160750a2c8e21d9df1a89c963dd2dd8d4efd8699e68d66843513f1d301b77046e7abc4b302b97a978d029db4d34e705ff4b242ddc0e1cd15fbabcac4dd6333b1112dd4a0a451cceeb05e9038943ac63d845cd1b2f9b3231f945408fa05592d47215d624d9f1a74ddc4406237dfc7eedfe2ffd16b3c6b09e45be3ad13f39042b03ba2c1c7a861d9383d705e842508435845fdd6af08289c57e2b10031ec2bce7c7676a7de09e948535d465527010861409ac13911bfff91f43ca4c2f2149d818b06ca6f03e91327f30d0cfcc2a635fbc6943bc01b2a8eacb44187ceaf2a9587968c1c870d0ac54dfed907b369ba7d60924f8ee9eca69c7e4908fee54a75bab8c2fe652668199847cccd34900742faf8f6d2fd5b00371fd328100f1221b1c3dabd81c1caed6be9b3fc5d07859c6068e09a3d11077ea868a56a0fd943ddb0ec2abf2201db38b2fe3f0a6f1bd5e957c380d22ff7730adc136771ea28964ca450b1b9947805c1ef002c4b74c12659aec3beb516be2e45a3876238c43d4dc87f55afc172a1bebfc9c1d7189abdbd12618c0ccff","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"5bff68f06ab680c994ea76941c40f8ef"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
