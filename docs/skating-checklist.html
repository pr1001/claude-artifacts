<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Claude Artifact</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Claude Artifact</p>
                        <p>Enter the password to view this artifact.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0b109bc4422ae2a50135b6c05ff97012ce6526f28189410cd813a5ae3e75f293d86c1ad65771ab9da24ad14874a9807d4042ddd2786b05b46b681d090e2f705c3fd7845812cf5a3d0d9f0d6bede94c32b427b596266e05ce806edf3ae5ec96eb48a388942d2a7accb729f22909b69a6a0c9caeb0deda2e47516462224257af7d4b43b3a03083723e0684d0d7c615edaa2478b9e9a394cbcb173ab4c9093a3dcd1ee31f6e67d23f21843fb9fed4096369fdbdd97f2f70c3ed387eb26df96434de46caa101c7b7681ea6d4d7ca446200c8b77429ba5124014b3259957e2d9854d04d73fbbbea851b2585302c4d90c739261cf115d051ab5ba18c7a7880d1b5ee3da15b9110ae0f8f031a859ff46eb9364eb4ab5393cfa1399648b41d778dc070b77dd13b009fa19dfa03c161112631ec7e80d639af4b4df254d11e69ff29f3376fd75216b1e21a453eeec5d55a5c0afb6dd812258133ca67cb9bfa3159137d1ba679eff2bb9369115b2b24ef693e57052204b8991076861dce7272e0ca9566a615bfa97f58e08268f9ba319cfcc7163a692ead565c055b482657d3e946d92c8536a4b8c0a82dc0d576a7db42777eee8651d4aa6855f0b5d46659cb22b8a269ad214c7de071828bcbd5363882cdbcbf37fa6dff55fadd1f15fb75fbb70bd648e139036a9370f9a8876d062927c3f9ba44a71aeb661890fcef7875e9b1849fdf627e494cc5f3c636c1acb59c4821a3ddde5a3b6d826d93b1c7318a271935a5ed2b8ccaa3ac88b7e8358dff90f37aed73c38ce3932585c2d53ff328d6a2c8594f248c945e18608e14a615cff5f1cbdd9e1d87270cc849c2aff08ce61436215c9a148ca8f688a8706796d83a965b0e705fb891aac74366c9f956de90c8864b0b33b69a0fa567e854bfd7f3be2dba335a3e1ca986a5790abd83496cb602d4efa31554010a59d56ad012d8c06d3cd2fc4b1a9b90ab7f5d612481d58001f571ef6bba0c3c611bf6004a3a714c48fffd9b73acb04d9a122bc25ad7ffd1916c985e117da8d1abd4010a46f9280db4eb450b50500d36ded1991d2fa0885aac195109bec2fa351044633e13653fb0fe634204adf4d4d853d31454f5105d5cb2f7d9709176190ef26910e249ceebe0084592daacf90c815b8048ed9a1558cad51d4eaa83767293936b3bdc236be7e829bc03f575c2c6011678548b45f5a093e5ab6c5f24dca23926243b5f09afc707cfe5f8e60e03d08670c459934be1452f2b9df5bf4ab6ced9c4d3dc177155c061990a92c6f551305bade6bff63e63d8f69d46aef27951dfc381deb8bc57f244ff3ada67f3dc9960c5909b188306a873c8eb2db9c238ac15ff6db0333ad1afd2f985c30b59abb707500a1737fc4c62f02f531c901f74aba5310cac254a25ec7b85a0b99ca50619dae56d8d8117264fbeb46f7387b0f6b5dcf5e9e8ba2b34869640b7261c1c679de2c23e072db9647ff2bea7872468f15a8c9acf82c9bb7b5bb113200addc5503f9409fa241f5a5498b0c2df0a0c4981c1bc175b54bca648c9cb8ba4a33f9ae7fee65d9965e2b8eb72c31e470937350ef421774074675238bfd7ac0a892a1aad279085d09a3e80c193b07338733e4809a92c60e0d4c5e70b1729e27f27bff7ab746f03dec49cec3aed20e90a7fc69dbb6cdaab25527fb1acb3bcaa763b5728ee86101064fc3f53ea522a0c20df5c8a3c4b6973fe4c641537554b64032c9d3094690a0af0aaf839d8e9825a4ba1ad39df4daa929c816bc3fbf01097a215a97cc35154e674629e0eebaac4750667cba4e980708588d717e2741c524f3debfa9e0542846b5025d947ab9743c8c6ad2483a144eeef0e70a5f345774a10c677c5931faff70162155f89045cc7815e5492d96499e5df1e773e248949f318d258b2f5a4b098917f1b8893a7daffcfc2f2ab91f64c6a52122116dcabf2aae0aa20c7055bc50b3bc9ae34770ab34dd277fc4420a2bab74e2f26775a9f129a03a2a870413e54695ff9301d10f37f6c5386430cb7f416f373f77c04be70ef820688a99adc404e808b0befb91c011e6ababd48ff16bad8fed7f1fc9a82c97efe600543728cda7f88bfb1631d966e3b53da9a0b635dfb2c5f60f8ccc2e466a74d9a7b2878b46421ef2ae6e6538e7fb6eec13e2a86d08b5e61ac990d320a479705700b7725e47198938c48603d80c25bd0c1eda46bb29cb71817b1b2a876f9f4ee87218878b522ddeb45e3886a6ddfb84ae6bb878f83aa3250dafaeeae7699d05af7e02aac87e0891f3665d40e3b062feedd506a309661078d785e9c3988c5d517507df132689523edf42840a0573c8bc9970bbaaacc9fc8962087e76533bf32cd57bf6869f9b6b9a8e6da474e1ce307139a00e4e96899bb5cb07f4133378170b45042d12a5f49696e7c1076e90c90a0dd9c03fb3401188fb2be4b5ed7c1e9170618a493d32b6e96d021a5f8d27e422898eaeb6fa2c983ece693b20919b69f77ea581d44bd7352a628ab4ec3103dc397e95770950dfbc26e279bdbcb572d640ca8c230a3ea8a98a96ec91d52b1fccd51bf1966ddcef7af387238182e2fd0f0b7690c551a5bc4448e7a357e2c49e83dc31e1fe269fb186d161bd405a76d1196347662847a16a4cdff741d80f02d53feabfcd747b18b5c038814ee7aa9f75ed3bc824ddfcd33b88a9ae0976af95d64d6f009ec3c4a7ee99d0f266828ceda3470a3cf12a210554ad3ef65a8c20c3bb83fda9b16c865308bbf97927095ed79d5824338cd3d3cf53509fbe4a9b0e80f43bd102b9f19e205abf7484f898b32ea0b8776753d4078eac81aa430a62cdcbd2b79ace620d2078a8c0c2f230d2c93168dc183f6ec745d1d3ac158fe5942745b23e2fa6dc5ca5bd37627ce1347944732b3ffb4e19806f10e7de120733770faf31454a85cf954507f7b9598c1043b31027effd3d586348a4a55745dee44cdee67a63bc9fe87b1d0564eeba21f786aeecf730e1688433b4f4286846cb2ef746561597423809b6dd0563405fddcb9f4057f89716da3d2554876a95984c2222ffca3a5fcbf0bdc0ccba1c9d47440f0ee6c9bcc2dcdaa772a659f9b26263890c664d5af80cc1e70970c1112f0eb7b89d67df15184d1fef6e54efc59f433f423edc7b0f2c0fdd529641cab82a59659da367bebcbf0e86cbb07aee5d9eefebb91a91c07f42390f1c1136881bddb8aff452b5996c17b7a8013cc3100b78103b8839093ff9f67a93bf6934c8ca54cae8fc8d1c0ca3bdb0eb678fa39f70c5becc0c7ef00f6c60e1451ac78c89ff696274e6748bd6c2faf621346320a2eeff3c086946070e7b37871ab7decf59ae9363c571a5b9dcb86ee1f67c0ed2515071f6695f14891db09602d62dc03697ec7936e70642003f1ab892f37bb1cdf3c7a4c87822945f1964bf460ce4322c6da4c19eebf757b9315fe8885ed7ee9f52b5364018a6119a03c7e9e293ff3e1381fab4cd96ce7e635865dd94247eda51c91d0fb02f3b6d138ac2f6704e5760afc13bed96ba0ab476b25a29bda2ec3d491849e9dac8067ba7c77111e2f1908743cbe9165df24e69c284e08e8394597315797dd2a87e4a111570707486f52298b4154230ce27b565d312a2d731fb6c64371680083e3660f617393365e104c908ea061e7167bb8e40c8989eb67156944e869a844708b6d0fd30b3b5a2cb8a97b74124e6776051321c77868c7b035502cc28c5dc5b15beeaf540e4905e49477fc73a6806cd1ed43bd0815890584f8831bdf483b1ed36ba934cae4617376ef23147e8a972410a8f7c035f2bd6decc814fba3518c220575065552a95f337d2373874c04074dc5aa6f7b33ab9768419baa18a81840d4da5fa2da07e3cec61098a6d5da0712edba68f4d2968e1f91f7dcb91483943dbe5e2a6d50b465c84235ecddc1d7a20b6060ae6f9da1b76311579a98c1d729a5c8842bc903c928661e14d86208a1c58f402adca405b0bab300cc3ce0a5c3e581ffb163d7d1fc79cef7facb51412af22c895421c2612e6e1f193b196101572f4bd97f5d8c4d77a908de62937db658d8f6c0056def524821cc369b61d83a07da7de23b57f4006b0963f0336a30fa56ca4daa577563be838a7dbe5d594e7d67b2e2e7967960a5c0c153d71f859b7594fec31d70614f9fdb337aae1c58e29cf4415f72d8c44e81dd5c59fa601ff9871b724a755a9d4ae5630127802059dc156c63803ff8a871df61a799c5c27fd0520d3eb833c27d01d2a02c731668522348d542e374bb9a32b590c67bab62c2628482150b21ee38faac07a2dff672dcd8ef13a0c3b18c5e4afbd6410f0f029e57fb6339666b829823f98a2eef7ae224544e7b91b73364e0b0b6465760e08f0062c51cc778cee4435c9bcddd6122d366528fec591c7b780deddd9d34341d70fa3d8958b94b0fed577a19d892c9380841bc070f35e72d84b79a57074377b5825cb0ca2be0edf70b0561784a5c5bca1d10b8e07e4daf2649e9c0ed5c81df91d2fb7ddf226dd8d5611a97e970e738c69c3d3d7f9a2153960b02edcdcdf51331e188b25fef446b34aae929e8fe4cba6578898f87ac097ae3edef1bb44dc52906660e9f47077bd5e095f991819a421ab3719054a0032ea207e19c5497d26e34196844f628bc6eba1a4e4837d414cfd3bb38f05e3b699e7fa5bbe09e75e5a1a628bfa6cf8bedb1623cbb13c20d59f790b24fe95c0f692b9b9124f75f9205e509f1d189d268dc756500233c95c84f0d7ffd4205943dca6a1ba4eaaac38dd25e6d81ab2cd89f5c00727a0099f399304595422a4c8105f9f61e3f9284015eee140608e54dc2a236f4d766e5e3b77a5e9a00495109e9f26ffbdcc5b51f2b7c9872443e5fd669df17e75d42dd6d750f03b0a3ac25342130bb21da9bcffe4e86835305bff57e4c0c84cba577d9ffbb20ee633b103cde38d2a14c73ffe36406e7cfff4aa7d4a74deeeb5a0408a01aa34916662295ecd6aac8753d86526f7d25fd92a64a7037fdfb1d18b89d638778380dfd6c1c6d4ca3021d6b3b1b9dedc9864a65e579254309498b8bd76728f7d97ca8b49066e421528317c508899dc7dee224b6c8f17f9ce6b8a72a6ab1b90cb189a3ba29b28f4a90e3c0005f5a28cf500b5f5f5311b235286b6e3a8588b7ef6ff9b91db6f2a30ab8c7b3cefd84dc4be199f5f30db94ba467fc4640417faaf0f1c9ad9290ef91f68d8cf7b2748255920999be441a58293eefe7ba6cc663b00a94456373e410746ec5d499554c07efcbdd4e5c41a08052769696573d7f1968a281668bb118987f516403b2cabe388aea9fbf40f5b4e1cdc808766b766de2b20ec6a9221919ca40bebd251ec3966703eb5d03ae8bd9cda7f5b279bfd3b2e863ff49bc6df6ffd5357f29fc9fe4b7369ae8a68d1a13e757367652d91366a0be439c58aef33adde2e74e2688900276ff4afc82a148c593b8783d7b43934b5b17844805ff20c67ad847f838d50fe7c25f94512972d039302d5d899fb36529c686926858f2a905b5fb16ec490ff71e5d8cdbe5c822fb168f8110ba35620b1e31570cf7b72eb044a01714aa52ac2ba94721ae2bf70bf3e1849922d21d4b1b779d494d0ce1cae1f73794ac8b3bb3b89f97e0aee0adaee915e2411c1b20d93b0d1b1993685f3f33e4a9b3914f056354c3822b34ad5efbc83ab657479f7165682d32638736e88d53c319923d822837a2bec2259f62a3cc87f26a762869eaeeaabe26a09d584817d3602e4a163bbb992adf09f3e98cfb5b8e94c88aac401755d7e4ad8a857d7225b5b6406d078dda77bcc22d4690012424e9982e0cac16670a01db25331d9dc4d2ee6e74cd08ff447fbeb7ad95bac4bddf676e5e194dfc13ca0a2ba091e8e6c183f855bc3f0f7da7db0f707b0db6735a314abac01e2862211c46d7bd1726fca2acd6f8519e1acf86db4d4d1568f56e942a0dace0e02571cbdbe6720c83cbed608d2b97bfbd87e823cb81210f96b4723ac064c5170bb3b344da5a6ffc51c3002315f318ff7ebd0aa5486cd9c5757c328f0889078d6ce1591aa582a0afb2b0bbc2e19891487e753a681166ba7c4f3017f1cd145aa35256f0f1f38be202c8459d36e3a3e1f23071f9a9a389037674ee1d62846495c41c2d1579a74c9f2e41e5a64986abe7583f11287b64002fc9360ca3e100e933f338154e9f0d80538ab3e202d8d61c712f528eb7cd792732cfb0ccf50ce7357094e2d4f7a5bc1ae60d1d15873812a63ebcf5d619054194a08ab1362094f5b103f4039d4541011230580d4c8d8384ee311362567a6b7e8337ff0df7d39c569504fcbb3b5ba8aec56f04c40ffc8a6384b2b5bebe0a3c0605a830008c8c557b02b45e3cf662979242b60c4cb07721bc015555b3cd8a6c908cfd91e19c5f5822d2e995ca6d6ab94d6150cac5ba316fd7c43cf43283a6447ab3b60d529c0706110359c1bb0c6420dae4bc114b03c7dc553772da17f4b354604824ed38271ce15f853f9b7ff5ccd122769b44bf6066d394c40a43ffd3bfa17778bfa339a26b4a411332713e9feb161d57fe1fe6cd7ebd62c8b5e38e787b8a3eeed95ee3d790ede052ebdd2574ad0a5ba3e3f3f9d0865bd64f6e593de2682e13a6e151a6905198b49836f0b2e18d0c8e486a68bd5b00b8c3eff0842e6894cd48c78b970b8ba21177648ac226928323614520e1a395118e74bb5a9fb5993ff3465ee2d221220c00e6b032131a1e940f53bbd0847a28f55492b0f6aecfa9fabd3f7035a34bd04ac2904f8daaef1e99f731eb5f48261de0e5445b6158bb1af0bdb3c39aa96ee3207e6312fea98a599bebfb7e072527df7afea60546e733c3eef114208eeb1d310fdd66ac6557392ea61b47abef5507f49a9edfe7670e16ce524f72ddf319d107a3fb89ffa4c415d8a89f7ab5a373641425ad251d5fa37f7046c19e97fa43ac57629c59fc7412f7fbee6c673763c9e228bb3055f90e760bcdfa26c45f3f4f2a493977043d645d8ed6e725e8e2a27f5af377280d04c1d8ef373f0e2943d483a6422d67d4ca423e2a76da94c811f45fb7780f2bcf378e5796e1fa703c05e455807b52b73e9309a03ad30234c1f67e7cb868c15512d08ad1f0732bb7543bf2192ad9bb42c09effe64f763ed67703fabbdfbc05dd0c50d2cb499e2954c42c13b6a701bb4d0d7a858d2bf3383fedd5ceff55bb26a1ef681a24a7b8d5b4f1aae94c8701d0eca86380f104ebdc41a1d89d8682406288418565cdfb0b5271c66ebf4c8a17fac0b11b6e65abe189b14dd247de7906c1c0f59ba91ebd4125cedca184bbffb63bf596a8eac00d5fc518697605c06a79a169eacb85b2bb92861e8c03987aec8303573c623a8412abb6f8a11f23ba67c9e4788340f4d8d6849c9af42d681d5f84137e73c09b8fb1539ca07ed50bbe655dc1a20b6711a974e08128b6f81ea87248f0770417fdac6513f60fb96658d19bf46e7ed1ce349a91c609448318e1ef14773b243e8f3cfee8e8dfc9e13ae00dd8d75d0b0f970106e608998e8da9cc6c492eafee2a7e834845045df07f04c3f9d3feddbf1eacd3851888d14f4295b34cb65b5d02a15ad50b7240400da5d9b4897561df17e7af71410d5248dd595f7541c8aad20f692b0debba19b79ca95c95998b05cabee55dc88160fe3ac30237b94ed5f5ff92f21ddd1a34bc71f5e1514c5063d061ce2bf33646d3cdfbc36e1f1128777fe4c5fef8d42a20d2297d3438ae78bf06a1575149314669d30e35bb32fe7d0ac8ca016f3edb31982f22ecf9d1f5a1fca235bdfa3ef8bd85d48e32626729bc74af1670db4b2223022d0fbab7856a5a6b488be75ef36d835ed1981d2489c25d3141ce70428c7cb5a6d0cfe0ebe07321b6b0b5e2d7459784d16b0f8eead7e97a9ed1f545b2d38a44d5d6697719f69d06164ce7da7eda10baa083c18bb5f1cfca8c6b58d7e1e6d7239a3621de6dfa10ef22c94c50e6afc4e915830ad74a78b1fac9ca91d32c8ddd2fb383750946471f669bf31d507e89c692ec98984dee639dafb28c585da5117c4447c17e84b59fdf3d53415b490a1df088b6504bba8efb63f3ffdac2f326e6171a72e6137a7e543a37599c0698476b3a965a322c5647159d29a80faa0810e0ec100ef909338bf40fed8481de2aeada00500301368c846e038a529ac360ab6e1449e84a4b086870b28cb9c8a2882caa6a1e5515f43f0e4c21cdf170e29638384499ebd5e95eb61925f3ef06a19f9f31c1520e52e822aa6180abc3b16997875b9916b148ff97753ae56902d68cae13b578bb3c186ae4b678b1ebbd1533dca252b16767afc573553335e739d7cb27f8e9770e055182ca9d164063dfab050581ca37cbddf5a44ab8265496624266a82cfa0b4ee8ce5a699ec708462f46906198d55964f2f276bdf7ceca883767eb653b7aeb468243fbaec1d7067d8c8a0992662fa4b0108be51c4fb74fa1e97e5f75db409a4e6449e88e350b8be059239864d298df21e7adfeb3cc47d1bc7d01b31bb767a88a2c19e395d75a9dbf8bbca5d2a117acf2e70cd347766eb1826e2e297537bc531d465a91f4a300e804d6a380a94a3fb4f6490fa9393e79ba318cdff96f1caecd626f46264d9f6d369cc3ca7b630d9d0141f4897b957ecc106fc8c13c8c6789f9d2ea0d5c40dd2f5c08cde37600cb4b03520a34eec8fd33218e25696db9aec58744c0dadee28bafd51a02c8ce0479eca8a67e70df8ac257b147323c1562225e58afe5b3b09b6ed6020d0813be0dbda3fd210f042e04569b1df0c62ac33f2dd88179959a1abb3470f529c28c96fccb59d52052259cb8b0fc9489e253c9e152c28270edfbff12bdbd78f26d22dc9d8c78a329f3a398b8169f2a33faa6af7994d0b3eda15457abb7ab8e94347237f08f4b6be80e312dc61e97ab8ce95e3f2ac1f4eb2e4c37c10f9515abb51dfb2492887b7e06f95d6adb5e80153a54dcb832b9f547f452a3702c1468d85d963293b78a8da6d3948c71f82a60fc66bc59d1a57412fc6668efb53f96abd139bd08b8fc9f01f585616c6e50323d104d6417b2bfdcf99e044c607799dd65e115666a1942fe31cf285fc6c17adefd0305275ed245a2a02ba793603d2f4305a394df4a349d109a45388ca0145d29ee26fed06717e32a9dd485d1e03b676b4ca6a0a9a45c3d952b4f5f21bb7ad53edbdb4481c039f2a4bab599adb431f39335ecf7fd9d365c2697c7efbe73ea5178c8ab2a3c41e00106eaee0a1c36276a37987f63a81d13106ca25c60630fef56f21fa84e608ca64808b23affe530660617f840b66bb043a5d11f39c8a9a1e527b99d2284643bd89b32eb34fb232e185a250e92405272c25eb4a926db3a727a92d4c3a2d7590b5b094b4352417e5558e9103475bf59a86a7c0b69dcc6fa1d5fe33abc235b66ffb36f17e3d80fd1bf28367af8f361c9bbcc63927765886f3f06e591aadbccf489150c3f5fce16bd26782650efaf1b30fdcf5b308dd23ef359b3315d4336681a6b2c7acfa01a2e3d09f8198808cedd62a20dc28449e8fd79fa7f0196b0c8b14fda3d554b2d23dcae604aaec2f5951ccff3db68fad8d25f650e603cf7e73c1b4d7f9247f22bd53c23df2f670989525aa576c564bb86891808a7b1ec5ebd66555a606683f597c0a9a5c9354d2c69c98762ab42c560c129aef0476dd0550731237b6993b75f5bb59f394931ba0440b0affab4ba74effa9926cbea3d123ec002b57aa957ca614cbf5c7d7e5d905b4a5deb6ceb68b6c56ed96fcc4d89e744c29bbc1c04b0c016cb628408a602f218a7efd01c54b7b0244dfa465efae37ead7d3b732b035095fe07d2711029c223f7e284b7c8a44b272f3832f81c7a7fe5bafe9053850e0101af5cc3bff0c75a6de7933963070442fce6fb6ee04ced0c3a4d8c251fc3e5c33d1d1ff10458a0ff2bd464311280d3dd5b04ebef152b2cd9d710a12545a71d23677b5744ccae8a1b7ddf6465632f7baccaa04cd296b745ec9e397198569919e2659d8ae4c60c28499c9c1b10a4e72cf5804b90c4476f1c2f2c5b01b1286d07c448e632f6832708a6401f5aff1ef434219871ef6b577ea4cd87322e96a5eea0be33797b305b8e813823832ce5066c68e6cbea24b8ff6c9d8538ea693ec7a9cc99edca3ca9d8763c42201566d35c23be88c7f41780b626969f4617304adf3f7f1d027a602183629eec0b8839cdf9e0aa08f9510647b5d9c4fb738c7a737625822e894329a2927be13487f041289c6453535c5062359ff6cb3db59adca91ab3d305128c58616dde3038a3c9a92c98c5d653768a1a39f1aa4f6b2606d0d0b7a48f417dfe5a0103772ca0f4ae4b7f7093346185500d2d1d90f924fa1905be167371ff5720b46fa7df67c16bd0079ccdd3e130aa8f5bb3bc81a8f9e69ab883ea341089545443e44e876674960844e6c4e639fed2ab0c18e19b4d816460055915d82432b0d681b3f5500fbeeb3709dbeebb2e62bfb155704735ed9070ba1c76134651eb5923d40f89a940a6657fd981fb18d23bf60e0c8e0965628f2df6e2f2a70c5938b58cddce30f31d038290d11e1c73020c3e16df525f1a5de2381f3ad1d4522fc4b0c7ec7ac3896e3ecdca7b1112b24fdbc7be18bbc89d8264fa1c574a5cdf3120513e9097a5a1fe682e5a04f6666de2c76f5202d46d8d4df6a9eb02a955890d5abacea2b403e9c119997dafd6899d5e0c3f35b0122d2e20853f99a22ed064ba506f32ad7308e69d665c08f6236a9edd2830bc3ed5883a957352fa4d55f5320f6ce6c0afade1ad478a644027dcd3805e446e7e98afdd49dddb6bde6c2603b5812187713479e5bf2d07ed484c86684c8372418deb30a703750cf51e93a65958e59a4aa843c7ccfc9e06bc16ad6661b6a5dfaaa49bc2e49b79817cf681201d83b68f0541f5b1a2826df20ef67322bbfca51d72d8901b94a1ad504109c3433459f4478bcce46e5681b0a3c7701844b5ebd9591f6d0e9bf2eee8bb4cfe2eb8679c5c52a6642146f5338ac7225f6158874d060827d43489af48663a171e4035599ffc366017b658387a3db2653027ed9ace27c925c0feb12f9793c08ba2720eddcd613331cd04c903450d1bd07f0e7bc5a51392df9fcec0020e6480f7a3f6192fc0303ae12efa48d117c4d85155e01cc57b8e66ea0935c7ae5716b150b2243c6b09319d0b612247eacf3e2b0d913f8c89834dd0b830c1552f81d602c434976f4d0f6b2632b0bceab0984a18e8e775f30ed7052be57ad18255868fa6e9951a9f0f21338d365720e3ad6e8c1abc9fb45c2efdcefc00c33580915b1012396a04aa8e2025d8f3ed8f92ec3ffa5d527261c4fd6f87bda0aa5ff047473b8ab85ea5c126c9f195e7de8bacc1be09a4d89bd185946bfc44df6a2c5e5e95d7deb0fc27be4ee4bb60d18e95aa34c42a486c90738ec8a993d8d0fc3cc483a0a05ad94ab01e3aeb494055a827a41808be69dda20eb515a13248f977a1a2bf711d26812c5b2388a51c72e6582c7c2884722f826d476ea0456e0c5a9b8595e35281fd152317aa5a8095cd434f04a3fb9696ac2e58205181c4706c96a493d0f390b8d07e281ca834903ea2cde60b247fd95a83217454a90e0dcb8080118ad5397f624879372b5afac252ce184409c7153024cc9000ac47e1ed6f5be8f837b6785e3d0000a4e7bf92a69ecd08d1e2527de6e15c6e12d7ea4925dedc266f57a348614290d2f70750e5c8148c680b193091ced32fb7a499fa5a3d968cc3e7c45fd3f6ec164c34e0c6a40967288b63250d194667325c9d014ff47c0c9af494b99880e65990099af485b7b9169a9c565b520c88b63864b7ac0207bd81602ec0eba6838e2c154f9b4a7f65ef7416d60bf882000b05ef512c5891503513fbe3a5dee4c6ec7f90def5deed7445bfb2c8e036203f541565d8072ec76e5c51cd53749d542aaffd9decfb58423ec939f7414758489d412d7aeeba37de0d8e102b21ad47678d467570da5a9da030148622688d326fbd8ba6d9919e8ff5c99bee1e06e49abb9d03a5eebdcb6c06c97b24c101577da1cb24ab260048a5d6420ce5ead6787f7af964d2d8f4a0dee19c3f73ff4b8d5bf80eaac32f54f20e69df76b4792108e1d7617fb14c5b0432603ec158b13ef0c5d035c546840bb058b9e30d3b4a8fc2e7824d2df5da803e97863bbadc6c18fcac0504ebb9f89b863c7105831bcbb691f3bb142ce498f41c5638ffda1dd55cbed7fdac31f3f502d5dfbf9ebb4cb92cf4612ffa0e1a7bc86c550e3cac15b67dccee0e2e72c1ec608ca27987419abcc694a0ee0d1007c46f905e26d59bff110e004682dae77602b119046c8204664a9e1266688b9292e17d66aee14a17cb4bf999afd66552f369b3e76b8e67c396d2fa828b5eec56c0ff07f9c9709735515299438e","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"5bff68f06ab680c994ea76941c40f8ef"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
