<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Claude Artifact</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Claude Artifact</p>
                        <p>Enter the password to view this artifact.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a19e7601a8f0d4c5ccecb95bef4188133e9d20e72f0e7731d38b1369f8ffdd6082de4eccfd5182051f2c4efaf69d914d295a4d3c12ce44540819a9a4ddf098a5507afb84963fb3a0f02b76f97e3134b386048667ec6ea8631a297a5b0182904bbd0c5d91a7feea310a7cd61f45912343c83e49770ec4fd5148a3ff73a2e2e09bfae4202be3360bdd48923bc4ef264887178de9b30fe9819840530f0cc77f58df79be68bb699091b1ce1dc41feab3293b839689af11c227d266fec8c55861be067146a0a2f11f60b82f4745be73ba89771533095e75250762d954c12f6276e629dfa811c126cf3119d9b1c1d08c747a489a15a22940835e0a8c5f82a4e5371f4debe2cb4aa19e0cd4392640870b13658c8c3116a97682fe7787d46d845b67bae08b235f99e636af7bd52c6085103294432f43cf3eff3bb8c2e28d2b2adac6ebc53f2e836fb1492eabb91ae276a8b84852b309a81a87bf1f778ddf3adfe2a8e7873ee0dbb9808451fea9c351e9bbabc68499dd565092ee73395b5a434b3bc47da3b365a64788f10f23838a28a28fe3d1e94f04c187c596107bc03023bd0485de68a51cd1d8c0581e352fd4c6defab96408ef99fd653acae8a58bbf911c8acdbdeb40712fc8b0343dbf74e617a5f38c2815c548628dc45c8cc5e97e9024349d952856e8938946c86a5fa5a0a4652acf34c7580fe122b6d092b03e5f6ed8b23a21879e967223830c26a8e382675f3ae7ddf8a85708d6943c8b3bdd5511519a1a422f90130db88f478bab1561ebfead51d7f21fe38ec53d005e82320d61ce8fbf665909745eb3c21cdbcd860bbaabf3cc8f198756ab17651582d130a64eedf738b34b04fe932797f1f51cc8757a6badc33243452dd28e3701e695ecf6f5c88b4be6fe808988b0f573b6c312a7b303c65cfbce96119949e357e90d9c458bf7cc0026667a02af8fe3d9cc6158f43e79851dc06f485f20711ab7ba774db7ae90b9be4aadad90c256cb0ab7b4a2b28129cb0ca2fa22672ca38937ca54ef36e50cd77b2e2381285ecda8b3525af6fbc32be6a7f9b7c55ea7756c1daeada01f09c937c8a3af3dcdbf622b59cfa01f2ae05de91354bb30e2d99b761b5b31486f1571e413df835e0550bcfa6001e227fe2b38947d96fe6e5dc07753a35599eb8e8ebfa0bf67aa691a38e19d0bf9a7f09ec76cd912bee97c36f4318f68d3c79dd05e8ae6afa4dedb1556681546f4f9d250f00ece079e0e288fd70f7bd2919699fae0cc560d032ce6f49f66b6ffa337f087c6fc73c80edf4e967f5142467534fef1309bb6289cc0615c71e107523d72448614394f3452afd4407b803fc3b7ba696ab509980a2a2ac39747bca14d7a3198c0b2a9d13de1908b70cc61df33bd742bf98a0e72a2b552c407dd0c652db38304ab40b74f54a160d686ad4479d9441d58388c4dcb1a6a9dfa931872c6025a4796318416d6d4268104324dd0173b524df5b86585444c1626b1ba25d4049ce4054676ca316b6dc65e52e0ced8f1c5aeb3005416d7345af4b49fa8d4b7c8dfa92863f075231530daf8eb9c1d8985d5b6368130272bbdd731085873828bad0f80d2e4b9a6a0cad9a065f93a66991fd1e445107906f7294acdfc4faa360215a90e1eba90075f193a223c2ff80c1121e81175cf3321168340bf787465b2e3d98e8514fb11d9b48587288efc9b36743dc1a6e6faf09e950721b0dbacce3bea412bac56c1a5f48ebb961af44b8f89dd47c6e2d450dce84a416be5a5b8a0d54c49c4d674f2855547fede801d72269679c2463a779158c7c45c82f046deee4943e990bafa6bbfcfd75a45e67e1df233c1139c3ab43e5e0fdc6fd11a61e92e18e7c63d7ba5ffff51424933e7403aa1c0a4ecf2a109d27d6c9e0948b462d8c506d2f1244f669207caa4b3507bff8b30828467699b1d758f477ade34ac0d4a34242a2d8e04ac2503c92fa72de8a6214f9b3d54fcc1b92c8c9d43e58e9dbef7966d0c2e99efa2dc69498d4e00fd4a3b014c969b6843176b8f0a1e5e3e834d9e012328d928224b28777f9e6c97f96b0ed53c87f2015c9658ebfa65b5fa88e83cf57793f7f9bbb249a2c0b32eef5bb08a1accb54e9a6a51bf61b229c63cbd2b04de326e9ceaa24643d931915e9afe2ac0033880da1516bbf47c3575293210f96b1c1dc094ae23aae65b2e8caa2faac9ac110cb82ffc57ec2042fef59fdc2106e51e50bd94c74ef8914c991e695f62ef7b586de5d5241ea5c975725bc5eae11e55344cc4b775b4658a4d368e4b2c991e9cb5663a6ffc958bbe1eb531f09e98b0cc14a72e82c8fb3344d648de122579d056c94104a3fe3b88d82cd3bb93ed46cf01691c873391c7ce98a1d80bab148052eea6068abbe0facbcf545730531105b4f5382509d1d5f4f6eefdccc82412d349b8ba9708cb9afc918bf12cc7589d70a3f1d5a02aa06c6f27fdf4065024fd7001ab0a3b396d179928b5fa9dc5ad100a3958653b371c7fbe293c2d1d680dc93e972a7af1e1f9c569923ef64a35b0f4f74c7e9b706fe6e366863c3d31f623def242a73bf87773d6e9cba13b0dd4b117d243b72fa75ae2e41e3618d9d5366bf3a3d2b06d34c62f889e7556c32d300b7a4d4262a0f15d3bcb8366b01a4a5fe5f18ed5eca463b03dc8be14b3c9f219c980ea7dfcc23a55f87ebce79eedb3c5a5ed315c9af73ecb43823fbc1c19b45caca6a3e6574f4256e667a7ba311517d34bdbbf92a8efb4850b0c8e23ffd9838276df256609f2a7b060d41d058d6a7267755cd925cf67b8679c44c8d7fee95edc887001089932c3510b028b786ba781a1324ee04ac0e008afe9a9f259054db4acbcccfc97001c410225ec2be5fc1b57f9b0da74286f95f56a4b14212d1870f862759cd3c313dbfb6c41db6518d109e2a899c4dc79a009a020f7904d7c334b9fe863ee78061d54f054dc85a0166dc13a5e8506ea977276a73ce6c40f630fd10a7cf6914b9be3d33ac218e72b2013ee22e38259c03368f571b7e1c9cb99fc0e5d712dcb31e3f519561601da460d94ad52bf5038e3a748e36ad00c5d74a8e248bc516eb878fa7b44d5e106cc3aa827083569dab98f458cd421465c6fa9194f19f59435d509449c618c772c1ac9e71356513e2584c0cf55c9c3e15c89ffefca6c6bc65196e30d9ec1da55bd7a5365c81aeb7302cd34bf95b1456b5ef8ba3cd0933e273e1c321deb8a18b87027e3ea0ebb5e9b4fa60b6fefb3a0d3c78baffa89f6546cf35662f9b9b499d7244f0652e730c4e8018703b4e794eda52622f741b840b8ab4c6a423d185cb6c0a5f304ee5881530467efc1c4e10f630bbd7b95fd653ef8e221861852c9fdb7a90ee85843aa7b4b8fb365ab1eb7963d13cb0a1d0f3cbbe50edba9f498e910219f6458ae39ed387693e0e8f1959d77cfa7ca4a2722f67133caeaa5bcb8437fb8730bdfdf619df68c5e416cdc5db310892b36e9fc96a6316fab0c11ff1f3a767f3ecf190160b51daf62b652323e47b9e077b4a82b16cb7ed04b53a849d8773217d72aba01a175005cdabb3eaaa957864a9d23d2b7d6e7374e9be79f3ef7f0b5059206e7c41988c3f928d6b93969c9ec5e78b774860dd7c9cbd86f3b96b3c5708ebba411ece7364cf6f075336baf9ef67e00d4e1630c0876e3f6b95a05ddfe84ce5093475db3fa3057260674a06025e3f7a24adbbb2f5f4327c08d75a302f3e349ac112d97eee9a0f66e05487633be82a7fac659107482a7a9bb83e99edf2d90761f22043d8b1672f103d7ae628812c2cb2a0f0472c766e104bdfd210ee1f1dc4f8d9ba7c74b9cb9dcce89b6cc92c1c630daa7746aa3e5421f2ad6e8b08335bc1d71cdb422eaada6a68f90065202b4c58653e4db1840fb3ec9310e21e28d5a5b726f5df2f3aa12152305a154ee925eada373bd25cef0cb6ad3cb112b172d8396ebd3f5c2ab4f2a7b57f5b525ff322c20ccd51a9d6bf9e637f499ca8d9e68ad52be7ed666cb6d50e672c99af770e34828c097f1e47f6726713884a752524dee9215ef04747ad9c67acc54ee678ffcb40cc0caefe972e687b41caa5e998aa0b26ad2571bcca9fc09839e5317c05eb56385adbab81f28e9a46fc216127736584fb3ea26d77a8b46f63174c5f90ebb3d2cc6a9b57d0807cbcade9a1648a4df58ba469123ed9ebd306b7a01d32ae4ce56ed4ff5867a10c883b89dccb4221135a3fb0734e3702ddd9ac0d043ff200084f6633165dba679614ccfd4fdb6ff71f90cb014cd3ea3d6891fe5dbee346fbca9eb51a06f14feb4483f0ebaf8e08fa1d2778b0e11493925224793eaa251e732b5496d23f6ce917aff8992b745820523d0fe2f90d1e68be24cc8a7afebbdb88c611f1bf403e9591744d28fa6e256f4d55c356ef9125e642f0a783b85fd29e7eaa07e8dca95009ffe3e2fc92320509140bf1c034cbc32c474416c47a4e7b75b7459d2d6f0b177fc10c533dda6a68c3f7c4202d4566debac70691b18af165c381dbc96421184c6757fb23933fed916b416fe803261629adea3a2d31bb50f448cbf1d58a5a6b761b9fcd8e6585b6f91f502a4c626f714a9417d4556e2f0607e84418357614fb6059e656da747b0b8ba6366005bac79f76c65c1ec72baa6ff542079a623830bda18c03d14b6e81fe379a6f1e8223cbeb95948854628bcbde84586e4ff25f176739e99529f21ed41357c1df9dce3f6c7b5bd2fab50ca57cf1eb5c6b6522cc9ac2a2420d5f44b01239c82e3f3f5209c8c72a2bfe30ac2d8d1ac998d53209f21bb3f8a09deeb35e0097cfeaf3cd979477838ba9526b03c18e7c5e76c842d61193361194714587287a42da6a8c469dc5ea7530e80be140e065f8dd711dc26e450a218d9c1997bd2f31e6da696a603bb7cfb36b31ececea9fd34c99e196ad41331d46383d0593a9c47fdc887120f233c0ce1432ef2fa271aba380e9b27eff21080b0d8dfebc8431feaed41ac3df04cb17567296aa9b47d8cc2dfe23ef2ed1864f46834196f727bffceaa204cd16217eea8aed375729cabcb91cf2b84d705863eaec7a08e44c3d89e3177fc4af2b08b9d4ada1fbf62bfe23ccaba7f1d07218b0f7fb559a25b63e69ba6c0e945962c0f55456400dbcff1a0f6cab668190fb74074b54a9144eb1f7a4ac3320d072cf4a450ef80bd367cc9b7ffcb9119436804a5043553e375784b8e96d2398bfeb109082e3aae709573d884b020981f138690203b15e306627f292bbff71dace5345acb505f1b1b247d4bde6e04fcdabbd3f7709b2d95bcd78eb222f356799cb4bd370a517a29bdb7b34e3d717551d33c6d868abf300430d39eb2af67c575d4d7e062d50266e8cf12c42c4ccbae81cf020b91159e7636f0050b602634184f9420e01cafb0b1bd3c2c08af430e3a18ed807a756cb92d3f87bce5bd18e2cc4c5b3ddcaf6e82c1d1c282687309cf30e01990c888a2030d4ff30c233400153b458bc14d34b6009dc0c838de0ab2b880ee7627b34d64ed1b421fa4768c58236cf695535560dcb86991f93507e0710428f044831a3a328904a6b8e44ec33280cce8d0962caca996fd05e4c895ac0250c0fe4f9022653fa11c889babb9a87adbb90af4d3c78a853235f8263264c6683a905caa4fd1e460c57b8e48438970f237da7fac7006ee79a9e94cb8e3494c43a365979f8c5495be36f21d9f36c9fa56bbc3e1e53fffd27e2c7482e2ccd030cc17fc9b433d13c95350a97b1a941949bae74d659c3b5b97e3a48cd28a3e848b7ed646b670729448c17d1a7213e403deda47fc5433ebe216179ff4d70bd8a5e74a2aa7f9b5272ba118beda345a2b8102fe3ef44b873b2021297365d1c90ada2f39d1671290767171ba2af7517ee9774a16f8464c7bcbd7fcf1b530f3599661a608427d8525de84e98db5b60eb8092a684dd421bdb6ec9de98071cb9b0fd7b01459520a082b2339a0bcc634ee763f8622b03fc39ca987c7080ce17c2ee1122ea73abd06615c49cc3978919433170186bb6e139e46bf46291bbe3b4f61a18a2459cd1d3a7b43be98f1190400a68ea8c099beda42f6c8257795a51f1cbcf675798ebaf7e2d96796d8d78c3eb94e45385010a89b57e7cb35276c192cbfb182b25f614995b8ced6f18b3040e29e153ef8c84cc6d6dd8e104cf68547b4ab3aadb4311aa80f9a2a284a069de53e66c8b27fefbebb23b54c91a26ae5d838b747fc4a023d860c5c4cd03f63d38733779a05fbf8e27f388531911c06375160d936da18a2f7a880e1d0b74789aace8797b67e9da6210f9d8970aa67c7fd4631d1efa1de0df0e20b4efc383f30f37341d95330a712b7386120f50564bbc8b2242dbb2772388f43b396e11c0474d64d54d6d46c914027b5b214eaf392c8f88d52f058959f5dbcb1dcd4f839dbd8f1581a4d528a9582aca0477c8db902d244acc019d7dbd239fee596e305d846bec1e8e9d66a3dffef7a2c63c4c66b36fcc28f0f11e57a1c121ab3096e198a6def84978cdce4c7e24b9cb5896331297ee2bc8bea6de675dc7c31fcc2343b1b231d70bf2b8e591cf0bd35378cf8f3246bebe9e5556d238dcafe6ab8f91ae8252af4ce4c15df950a621a8edfefef31a9045b53128458008636f29641f545be722d556d142b0b171b859446c0c0ed6b99853d18f1f5a303734655535715fe2a0dc1c923daaeaa124c10876a9eb8baf433e6c7ccb893276b312f6ed56153a788d15b3eb26bb5d2c9511be59721ca4a7d14e5a9d58768fa397031db892639987905bd3e15e9f22807f1fbf6a4f115b67b16383cd89c0b1dee12f7398b139f23fe425af5dce0e8e7b17b36b699bfa88f248e711fdeea1d733a61630ef10bf813dc78a4b1bda35de8ce228dbc3bef11779ecac665167a2a03c6108887ffe4cc16a8181ba64384bdab370a415340272669b136225ede1880ba8dfbb88f93ef569e8af394b1c53330cfc7b43ab8b46db0cdcdd4b029cc22b520b3d36de882518fb350c4a0d6fe08d7ac5977b9b7a065a5890e28c5553a75d5649c4b60a1fff3b8b09d6f28507df5dc0531b3cf4f68d8962ec82b2514e6dfec9f409fadb39c0be982e4600e4f3c29fae3826fadd1f939c96ea3298d589e27a0bfe7d6b503c74d16e1941356ec4525fb9a10df335e2706d6ceee3bda6fc59eb39e67cecfa0cdb041f177c300ae63711e1f3d9f975baad67bed1784a4a25f6d07c285e8b6e788a071d97c78a36bc105a5ce154151bae94fbda4c641a682ea23ecc24e08260280d892def3d2779c032571cd06ed900c59f3577cca2717ac32897cbe218991fc86dd711235bccd967690e26987586d172d76b103557cbb6a867fb980663b074f63e4df39556c25a9011fef9a4040849e794a1d3c2c679aa11d1be7ba8b6aaec1c6f5b333dad468f227b0d80f411f1e0b33f674571ba3ad291c7c763aa0a73e576358156bb2c3af37a555e1cb531c97f82678d9641465307ab1382158d6c88dad859d91ecb9a71ff35eaf8e8983da11080d7eca8389537cdacc5dc2ae2332c4063887b8eab2b5aab414c55d45a2c86c9f5ebf4710be06029e22696495ef69660b6d4bc89de48e50c0731094a65beaca06bf27b1e6fa7466441092a16d4402c3c11e9737cfff41a4f83ca976e6ffee9ff231199af2ace9c36f20818e244a8c90cc85efb2ebb7e766f30c2d56c23ca69af2dea8787db0fe34a84dcd6cf3e46a7ac82d941441f4a6c2fafe2bccd07eb77062e33b1ab245c3fe7f93a7e9178c5692f28e47529849653633d95546011b4beb1c1bf0d2286d2693bfd6b2dcbe6c92cec89611b6e5db9fd0c699a9ce16f79cd445f7d87a13c6dfd73b711eeb9bfae37a8d5a24a24eb9551126178212850b976e8b47e84d086d29371151c344bd9b761eb6b01d73ee613fc6a264695c6a49bf2f8bd8b7dcf1801932a9e640f6a9ed2697dd0ab82271364c65b3fe67df2e0bada82dd514c545e911718b7b3f5c4833e66d3f1007452338f6328121f90a219f97e1b0ae29a127a3ceab97c2ba40b4e80a351e6acb87e829a29998da238d349bd1ce9a103419a512198d04704ccbb287ff9264ad94efe7f06c09ec3ed9d4e25fd73e800f6bcb53d94f789f1ab8e5baa1bb7a717d73202df1c70c5d5408c70246109b90f891a64b250e576942242cf488aeaf2a29c157f3f265afd879f83b37162c4f3c39f376c932ab33fb33488ba88e58955ed69f112bb20639d7db56cfdb39ae111d9cd8061ce8be21d4b74695d781c04fc09b860749ef43bc00ea88fff14833149cd264ab3d15bc364b63cb2d4840926cf4c5fd82d1742aec59eb6ecb34b23335bc10ec1186a5635b489623841a2d40d7be38e9aae198fe9d748bb41a0b195d040bf0acec4fd1ebc1bbea7e53baa2870c6f68124c39671469bd9b1304447321db09277e23523f64c42e1fadd46bd5fa60291f55d7032e66690684a511067de288a66f9b6e77f9b9699dbf43b964385558ac9c76c55ce7b57237694176f0d3d57350c3d1e8ef0091ebcfa2c287a8a47c84cbd326262ab93b22513e933a5d5d8ba9e7342873a01ea17d31b6c022f78ad15d808ca03511589890e058ccdaf4cc4a426c9e3337264b26eac972abde715c68947868950dc53a888cf706b28fcc83efaeb039b42d018b160ba741f21013819b706d7657adbbd031d611212c2021cf312b4f324530230c5cdd4e50796662e3cb1ec6c48b85ba5122367916d6757800288ae8516145f68f7b75d2d08bf3417c9c450cf6b2a1e4dd774b85d65783df8af01eeb3b238c46c30f741a16ea1e4352b7dcfb44a36271a4e36c2061640c6b2f2c26fdf49c534ba76f696e80b8d25bc961dd981d37b8f9195a0bf81d491d81a95441959a90df67632a2dc6c7ade3df77be31ba694a07d506b86a76670860da708738f035010ddcba12e14e57443b95a755e715e3aa3faa51372b0a063bc885ee44f5ef8f96968e5b2027c5970aa25fe9691cfec660c0f71827a8edfdd301eb20c674b6b11bed195f65fc30be5289ccface4033db9d80808b93f4f5a349007da11af48c0dc3a8a142f6355c937c82b2a598396beab6e4943490a0393ec1002eeeb140d79caf7c4f01546b62ae7258a01c0f76f9e56f3cfda77bdafdbb011d19af00fdce1d716f353b8675e2b5c59fff0c05190c739b53ec34a4c402f8c0e876793c53e50bd6cce8c327e993785f87fc49f87069b51dc17423bd247073ec0969d4a0a3da0b7139add5c7f319f27cb1efe530f98c1199e3a25a5d18a30aa58a21be438733edb539e7ebba3e9a3eb679adbd6b5cbd382a23446ded8173805862287344846c6f4194659903839085d70076dd6759daa8e899e47be90462f7474227fcaa90e2b5c67a190ea92c518f67631e88e38bdbb62eb4c040ea1c4839c5a4d22f9d57ac9a000c759c098d99953ee8ee0c7a2da7bfe37163ebe03763609ddaf9d9c3884c939a07867cdfb7b37093e25683a60c7ac3650aadbedfaafaa35bec40be9edd4144665500bc188cb5ffe3e9879e556eb1b36482091aed75c5be83e075b21807f82731e7ec3047d4fbd49f7428f1183c5d07599445589f5a48aae4f3ffb0fad35c745e9447a5f0ff0acbb4dfa43be54ed59a5ee599b6fc6cbeb0117f07201880494b0f28581d5c1c64447e1f3d9aa3ba106834391be4a20656065470cdf63f812cb5ade4c1a46524b9127caf978e6fce01659d3e7f7e589a6e56dbc30e1be6b2ce5aabb5eeeba436cc2fbfbcf1aafdfcf86496a8f5428311af8830fae08493e15e6bb570f7d60f3cbcc7bf99a1aff3ac37ef32468b67c92b6f4969ba7c85916055212f74dee88fb4ead06f563528de24b27a36f0803d687016278ef1ea491d0913b67cb2483467f0835bdf6e63dfda65fcbf5aff945524e62c641629fb43172c1775aab3f2b47feb41cbca43743b76cbb93a28abb43aa66f5a87f2f00e2a374276ee896732dff66d8e26ef29f621583d744f1cf0bd2aea167db523dc8222b1adf9c99b3342d2ab8cf8e5ab832dbc2b56d0e9a5cc4cbf30ade6ac4bda5edcd36b74409a3977594e0a812c31c0bad5dd44db22b554fe2a942e88c7f779dee76b0666c498880fd4308fe9f12302c14b35eb2f81299353449149e66b06001e6e72d34ea10d1fa804ba93d48b43a85d8946bcc0b32a329f636cd7cabc76216bcaa0581f4314a6ac48fc63f1f24a968b591140ab2dd2d7966d9872efa156b3d8953f1cfca27bc70f83f79679361192de1a3f05c12ba389c8a3677cae0e4549442968e754171a57193aae3f1ecb149c098758c90e5c0c6a669cbf7e60bad4e7b19674811530b0339c05d46e2b123a8e960a4a1216fcaaf9463dcf0136431db9e28e97a1650cf9aa71cb2b4330b333329813b95f72e613287f74ea50a465177f44b58fc799229f2245b502cdca1f5d67e9bace7d4cda77672869be8b76ba93c21dcfd1afa42da3e3c3a0ada98fc4a5554e10434ee646752c6f017454078e7a69ff50025ee18a26cd89a4bc2024b9c27f3ba1527652fd6a50466bc294e4f47c64e0ee6779f9ebd32e9c0f749a17ec11c9b5f238ad9adfed1dc4f971fca924959349140df8d25a93c5f10b44a780d483d6b4066b79126bc9225a454f758d8f35bac917b9d437df985ca8e53c03a273ae9cf278abc41af70320a48446a5b188cf8bd8321ec8a7e134fde1d9e70572787e25c32b485aaaf4542b7af3593d3c9fa0e661734bcfaec528506547ecba53fe7fe90ba11c5b3145d31b8a5e5cb65911ba79ff7340880c07864cbdbad9c0daddd6c49f083c1396d5024561d540b8bc84438c9b8ac8fca59b421b94076bfd7f050d0e4d057a9e11234cdd9c04319cc620e6308ebab770d133f226f3fef9fbbaed12780407508c71a54592708a006a1f17761ec72fbb23f67ef203d429ccbd879a5b2c48eaca1e5b228e1a99af8b900d9f8da7d8b50b968fae370e789722a56a1197f33ec91c40ded3542e3b4404eb9d95f519cf38391f6596d9da4f9f823062baa1caa6f9502d7945bba97c434746ca377234452891adc6f08e54c2c636cc2b5cdcfc3d2fdf3fa093584b6b0cba86fc853c3ea7f3b54ab954fddabf39d30d8165dcbf6a186f5f0dc4198be6d4fc8e233ca98d22d5a37c60fb1478668b69364019c8641251a685bb4042e21d1eb0e29221693e645165adca2926a0ef133e755ceb68044750303a4dcd7f782bbd39ee2481decbb47cfe1d83640c15be34cc6aa6938c23fa56456273d9ef8e499cfdf6839f4ab33355bc4a694f9485077d6f867f7e62e1d30f6db11b7923b7dcc9c485c6d9612f51b7d21ab22f9d991a516b18898874ed8b2515b4ced71e274ee697c9aa7f1d2b66f9f099e99f2decfa424a4288c6462ad3d50c076075eb928f4d505e9ef1303ecfd2a3c250c91487c568b0cd67214568a1e0dab8f46c8ba6a94983bee116dee31608bed5f2d475039050e13a6d5f6296cfc56b0bdaf52909e6551876bed948499ba2a8ac17e5f19988e2b35f31dd42c04a4d4b66c5fdcb3803bef7df2c12829b99c30782f41303ed01615592f4ac382f8d593df3dee99643384ade54a2b679cbb3a43f0d2c79866e3377bef57f0d67a131678584ce8c42d1778532784c8b66252a4e237629b28e2b87c33c5115f23527a63dd18ca48d591a68255849870121f01ef54aca8e9ccde3f1aeab0359fc7dbeb1679e49daf6e9586e617b26cd896acaf79d011d0a95be25bdd213a3a1f92db38658c67073ebcaafff48f15022442d83f9bcfbe8b11ff5192de29c116eafbf66ba616b3fadb9b2771dbdc351120c005642d7c7b10da1e8a75bf4ad8e5fe4df14a230c59d488f0706670af56605cd94057d63789f0aa627b8bb6c2aae8e775a13983aceca9d7a72bebe868be0b7ac6d583ab55146c18d42bd24114cda83f891425f5c9a6d64d75670c278d891d428f4aa755ca49b7c87cebb91b3636ff9445841133171de595488147be5e73e24f980960b4f1fae83615b0269c75040306e434e6d186141520d4133d1b3d5477f68d3288b36b0c606e44d98fb172b583b93c989ac819d41ba14e25c04aa0c4370f9fcd019542ecb8e66d4fea934b333630656e9120bc564b5ad20090de1d6d563c326382ec2d87f79bfaa79471f310a2264cde3b1ff04d93a7f46b3c1e136dcac893b0a5afd3ebb4e281b5ac759d2c6a9048d0b05ca370ab27b040e1b79ab10f534323d447917993051f7e44a3aab97b58f45db0027e68218bdd0f024d9464a6a13359739d9faf62b331857e76ed292c9b1f18051b404bbac1ebe323676d47a5a18601a7336feb1913eee82ab5346dedb7a10650a18fc0fbd9e074d8f88e9b87639c52b3f0e37d3d8ee23176e608ea208db94a5c5c1ec3e2a261fe0aeb2c704706db76b","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"403c1e4255bcb0d527a1b421494513a5"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
