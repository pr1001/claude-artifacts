<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Claude Artifact</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Claude Artifact</p>
                        <p>Enter the password to view this artifact.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7df9dc5ade56e2edfa81d8f165e70a8f0f036429167fad8fa651f55d9e7acc073ee229a0b43a1a07f1509883b7234e2a12d125c09ee4d2977f5db22c7223aeb20213be4a04252e204c7744e7a31b8667159e0974e6b1078e924ed47b817eb16547f01b97e8494d3b682cb914aa68b7a31fac3f4e7003f2579213879afee74db51a93c953c50dd731464e611b4abb0575b0f271a63bb95e7c1c82bbfce9687c53f640344bca89662897a5ed5a8180765c5546f09f799c0a01cf22ea3dbbc5a1a05b1052640a302ed876fc23dbefb8908102af77c9963905a55085eb4d98a3d1ae87196c062df0c6367cb84160236bd39707fea8d77db65ad948a58d462fc599f4130d9cb4d62c164cbb73157a5e4a6685631d17305e23409899d7f81479242bd43055e83a1283918f394d56972f0e44c3bd48da8cd1cbe0af7b6fa23816e6b33fa6c9833a502a4f38b81cb394e4b58ea2c318f955f183b3417262e3108a9809397b7c5b204f1a6fc41d5849a52ee50f2ada897bbfbfbdde6cdb6b50b3f517bf637ac4ccd4cf45b9ae996a26463e108ac216daec66e86ac7f3bbf7238733065fd8811cf346803f7a933032e00d0533408921a543b942b6d5c1152693bbdd4540f0c616835658ab5fc24f820f35e47f1aff4ec7a9b3565ed03084d3cbcf5711e5011d2406c94728f8ee21d2d8022ce1d55470fcb9f1d7242bf4ec4e5c79b09a44e487f5f16ec760467270cf0fae34126654502184fb6b335189faf810e4fe11bf674bb54b73f4aae9fc5ff8bc2e093d885556a2b078672fd888bdfef9e53590f8a976b5a85727598c7ce350f4f72c934e9cbe37505a067cd947339f9e8aa847dd8cecfa6fb2d2957a454b83604970dfb9d8905ec5e5def61a2bb3bcb085df5eeff9718482276f423f182b05314b814934b7dff90e8b07b21977a3fc7a833635901a30defed450166cffdd6ccbd38ca66da9a519f86a20dab46872df0bdfac01b9611fc6c953f977354554e15a37ee6d291ba983b761bb8ea614b7179bd0f42522dfefcf3bcca7367686e6970731a1bf7080b8c5de18a2c1d6997b0aa104b63d312696b5a9ceb8f347c280da6244eef67757f551df3f631107c2a610ef8aed634b8ba0a0dab5201a2aa53d16588ee4a461dafce37f5064c803d75431517c15611dbb798ccab8cbe3b1b59c088f2e8972a9c87947feb777224697e27ae73d59db0f80f48cdf9aa40f0b2ba732864a0b15d25b2d43be02c14b047a96a931254e0086ff68ae821aa9432ee5ab3b940562e7a10b6f35f10aff0897fcb6f86fdc3960f0014f9d66b9a538a78b85ec3ac4f8401def2502c43263a752a10a3fdbfe67b4b6f5a292b8ce7f96cb84c0d7fe88854ee48497c6a5961daf34c05e7e93620543055c4afcc421c476422f0b5745a2882bee8a3d277a57f720b8bc534edc411bb89770a1db817365628b14435aa1ee43de8fd3968e604f76d756e63b1acdb2192667314b862151c429004855f1e8694d8da6f3663b74956b04a1f6f36509a9752a83492eb208737a37c09130020219577c87ae390ab6bd56df86a481f475f5731cd6049c1361cdd384d9f7af87a8f7f523b3f6b644afd5b5beb5be39a89d6d00f863cfe87d06efed46cc9f954b96f131b9780001334ad226e56f2e125cd52dad900ceb803f47994ec02ff3d391126b38bc3d24755adb4724d36d5129b4ccd4e94790b0ae9158459a8d530e614f673d2f8ff4abc2ffa262869ab31a0e7ab9286f87916a13982955fceab6cabc45d357e72ba8e6836f16673d83849e2ee73ad9e6209610100bee9e3a0bf22b09853d6da8f78e0a9b0066e7847a4e1ff9fd901470f1116457c4a7c9455ddda3466c1c5a35c7cccc30ad1d6b224c7c5c599613786ce4fba2fb8f2a5458b707d4aaa8f00956215e2fccb2f08cee2afbe33be000a4316217fcd3a8d042a1e4f1c8ef3cae04a9c13c3f95ca79b0b5ba501531cdfd39a81eafdda3e276c8b9438d207b01e37e9047f34f211a053458634c2eed95a5daf00151d8da9e718f1f32fc28182db42223b872b9f0f656581bfe1cc64b4b9129d3ff18a16b0eb955a39241567f0fe7735aee4b38bf3b8dc93f3824ae0ae985c92ab2f4c5e2027e982c0c9089e4cfdad0bfc792fe2ccaabdedc84e9bca02bc778fc4b1a3eca16dafd35495a3800e5c2ad22a6d29fb74e54bdcc55772ad5799c13e7dabc8ff68795c794d0833acbbeb55ce5761fd31d373b78c41abf9a14f5c057234b19613234c918d3e0a6595222b45878f4116adb2e9e2e9de52e6bc312d1185ca152630755c90eb374708bc30e8372cc64f389903cb32d28edc6f6df5ce0e65a67bbc4452d221e765253228df39cb27dcf7da5d184e83473e388fbcd745ebd231e999a1409881b55405bd2f2e371b45f9bfdafe4f3281b0148ee15348a9a40a4fc3e86b81b45a5729bee8f0756e0d13cea9acc02cc952815d1128870f5b1c20855fc50bc410fd21cd1817bba451735e37ca59764a6bf6b5f8ace9f1b70b6d34d56e98d8b535660fd402e8cb37d795e3986a76ea997784f856acc0e41966527f0f6d287e35730debde593c23efaea22cd52ab72b59a4cded9771c4ecd5618950547e81a48ad4d58d8eb61f98c67199ce5cf199d971cb85bc96452534f1a715eb84b5057455c8069fbc8515416ec970afbd34896f0912bf2b5328ddae84c08f0c711e6dbce57239fd4b0b40a89c39d3eb06641d33febd6a40e3ec14dd412c99952c9e3915518f880c731717ee55294f237a253369089371cf98f5197d3dd1e469b1b30b52edef14f6625f500a3a764a94538fa892ddb045e9ac438a337b29326ee057d88915ac4b8b42e8bcc8342c33fbaf555fbf216607800645f5e119c71dc955c607e7e668e5e3a24362550041255ece84e25225650ae38ddbcbf8874240d770908dd4be69d44e85b071fa85d848301623c651704d5cf7294fadf3573b35e616d19a488b3ce28a9554a503707e5338285454397e979a80a05a8c11acee3cc38d3532bc1c3fff91ac90c0a26cc63687c696d05c97b21ef39a5d6213643e5fc8cf17590fc987ba597062bdb65c31195eb46a7bd68172256205668d40a0bec9a32c343994b55b3bdb182f137b805b8717dc7d093fe2e1400ac93292c7b41a9529eac3944b700dc29836a9eea5b6dd51e054ff2e48172e4540386c86d738d004b048e9a97fbebe57a4d98e43a2efd1cb5d1f2564b4f3b1bb74a777e1040f5712c208052f13b4cbd64a91bf86500727757bab89522ae974ec8f058fb97b88fa8e2c271b3c8289d071f0fc58c162b77ebe3707f79dfa6861fe73bd4549bdb5a7f77c61920c9d054851398851ea9f34ef172b7f5868fd15b24089a43586dcdd334f8455c4828d0e43a17bd5d62917529079c835dc338d009044397c23ad04f5efc961fdb7a8608e63097114e45392c2716b98af09856f3f58c5936a3490adb4341a14b4e2b851f593d387e7a2a2a4b9c2ec98f83349eeddc27bd6c630df0c27e9d41666b96233700611f54c4c22b84b307693a8127227c30f850b29ae85b474f38f5296d2a26658c233760962324b3ec85e5342d7087fdd1868466da4fbd4de9d07cab6a0ce3348f7270561eadf53f39fea98866925cad76e5a323c783079e36ea6fbe07baab1510b97c9800f4c5292af05102038ff516152626d68f60d364ad29ac1fb17502d1e0b04269b4dbb595458b51700eeafbe26dd9d45daa0adf03db6052bf89039abce4a714d6e754a580b25fae5351262583f0add1a7702188004f4036780dc0d5959eceef1c237d1e49e6823432344d32c6c1c03e1ce62c2684500f9b7b1d249b1899205f5eda7d1b2e842cb5e7048805752806f82f0f5686973ee58ce3920241d28036bdab09446f94095d9d32720d85b5a5be3bddee9784561ce18c9252bfe85d4151ed9f73bd7b78389e10953bec7832a22980dcefbe6ac371b0a523dd334902d8257c14bbf0fc39a96e487ad43a0de08401a96a9feda9ee805afac57b184bfdf34679fe3293de37e9417d8b968fecaef4ed18801b090e6b872939e4be6ffd1504e6f1e6a057eb366c03c849648529afe3442f20f4992694a23af93199363bcdeeda043682727af463924d109f535924adf60f529e446ff7c1bb67e9e35eb78af08c918bc9fe1f72f987144a03a484e1c660d9ec594a3e0bdfcceb2fcb046cb37ef6cc901c828d59ec57d60d0d2cef83f5428f591210d1730a6a1360d85cd62df47bf4a278c062f1d66b379bda9eb197da1203ebe80991c750e8b56fe9440a80663bffe820d2d848b979237e2b3706147d83bd7025e50122f57d46d2d910e4d2ff6429633f4591b6963ad8a3d233e81ce6af2328df2de4ba3415c2a9ca9c9e378e2add66afb71049e1f5e4143a80b290ac3ee1bc77e73ad2d81ca6931d7f726418df17bfde6d71a017d08c7999bffeb9da97a0d3d68ca61a54d41a3bab9fee2b1610dd8b36619035fbfdcbdb1a97edca5f4e227b2acb0cfc71f121d97af6669cf80c7fef938948d3e93fd01b7de264be39aa2e976b90fb37a9faea686c5862c6ffc80c2dccffab6ecf2654fce3e8ed75bb13c529a9b1edbaacfc573d2c4f0345e25c64dab3698d4f682169f7db33bfd6ec03c067078221d7d1c07dcb3f7f42448eb5b26becde3bc19bb3a5a142d9f40c273654cdf344c2516f7db1291b810c1187452d3294963488e0c7d2d0bce2b4d3fbfe4e879e489acad56c77134ea20ea51de072b878293095a7557baddd4435b83800f73671f46a9138b3ca719c5baff4004d7c4ed43a63255c5dd61e05010af13bd72974a357e4570d0e9b9118eabc1efee3ff2683bc520ce3c1201a7e41e8917def5cc1cb29e49a626db8c6806c4eb967375540ec89d796290a164c1074a0635ef484ccf4b738cd9c62bb6c42f44d55a6c38d958df725be1c649ceb5d717c10f55bfc75064d01e317e9cc3b7b20cae2ae3fd7e9bb5012fecdd7bfa7e007b9926e8858d2fbf7c5e49d57fdfa255b1036c77689fd6f3d3520c11e7ae6888002bf48b4bc4eae69d30dcbd8d6f07e75d2b4f15af9a79bffce4dacdb8fb53839506b4dacdf2bd293cbe4be9fd4a96526944d2133b1a52dc7a0bc3fb1111e93c6b0062d5f251d240ea5b5f6f858b1ef89c400f3d85d3a0f96b1d95b5305b9c683b6e6d420f25f7bbc20bd72b6e6f67b287a93d8157d9b21451e576da0c93c58641b385214df2501fd614ae525f1096acbf3698bfce4886dcc67c0f8761b6e250538ce84c65d223013b344cfc7067e5f3d9fecded017d85ed8599e63fba4666ea5d8acb11ec12753d3fa5a2bdd5d607db321a46a2a9a3040e3ed61a5f348ad862057a760e08e6f2417bfad9fcf942d62000d7bb736bb658cf78bba42fa0b9b1bb17a9c8adc56cb1a3504cca386d2914cf736c19bb5acbdb099da66571671e65f6d756f8587a6b292fb20098cdf7bc285ae5de595d43558b106dd0595992176ada63a69c44e1743c36731a8c77c6bd3dce9a89319b061717d2d22621d2ee853770a0d452caf38213e0c9a367f88feb2cc5dc342e74c26a4ccff62e298bc9214454a641cc0e15dc99e6291f57e653ff7376ee327b601a4e15cf90a8a67e3cf466b5f8e636d691559f59b78281c698ddaf77e73df85922abb3b76da8087b0e9c6c32646a8e8baa6415ae8fea5adbe7fc611d06884c7e71758692e4cbe966128de0067ce64c215f2bf65b3c24fc80c91866201d91460c55589075f0e5e054851f2e359865860cc90f5f92909ce01f09853d3f82eecb177d87b12f3232197a816101430f31c22211ef0aeef6dd9433980e004231f46034d04508bfe4f78b2201f926e5d5c72e68c41befb1586c798cddca3102270b63e03d02601ce6e28dc94f1c3a5648f009f9296d94bf92e37f8569c6c76b19fc2363c31482e9874f632c84b0439fc84ae168a1409b289efed2b88c98d5184831ff08ba97b433ebb5054fd18ce1ab75d7a342be2d0824758c96fbd8bc1790be86dd145771d419fc45f81d454a64d577a524717299f7d8e14db81e689b9f17041d572bff029472647d09728b8f4e44c14fb4465dce5cd1c39655b2697bbec5a29a4a58416f7d12ce608dc8c89bb91ca602305ceb4412c69d9f6c3c81d723901cabca6267d75795090a96cbdd247c1055a3b236345d480f35445e21aa0ac75eaad26451770aed2f64afbc94ef2e03f122fd4506f3e3bced93932a7bc35f949231fb1127ae98690382bb0b690db116efeb3e9a670feba07d83aaa5b80e48ee693c84e4e3a94a2fcd09d8274f2b732c23c4d35ef0b734684b4f8c884f268c69883b11d93ba493ef6615424ffacfd448ecb7bbc8570e49bdcc8a586951fa38947438fd13c621910a6cfb0b2cd522124f4ee17b1cc3d277fe8105e43fbace8d52279872812d4e5c1a99b66ebd2cb093620f7122a0400f72f6ac9c31db73098776eae356462338c29b6c3a6c6f4afe23500dafebbc0f34707842d2727841465c50bca32bdde37f7577cd13984bf8dc28b851d875a163d2b2e9b10642958530974017fde6345da1da139febd134a27190b70dda15e42ddaba7275ece5c306e1cde5950eb4480fae19bdbcf1fe9f911db71444ba7a6c898b950ffdc74e8038f86587adba5cc6abb56ad0946ab9a0691f504f1d44a7cd1ce273e19cdd157ed8bca771f2df1a0ccab5d261a6ba07ccb16ed614c78c6a2d431f62ba065579d549d7e9a30691ff5045d435ede5c3a6880ed14d9aadd905dce5a4b92d3cf5fc667bdc571100020f78b31c7bcdc6c614efdf1dc7dcbfc2e2473a7cae755310feb5f26f1cdfba07e325a67dbdea29b670e6131d272a0671d1fd29065aead396803e7c4ea31f5248265f0a58f5ea35170e67332400e67336f143a5289ae4899a2346c6e448b19f21cb4b8d660fe6d5c08ce849c30a5e7f7130f5aaab4d4b6c6562bfa9dc12d8384920abd5bd75724cc2681e36d6c0e4d4342f7ca945d844eafeafd61304e31ddcce6a1bb3a2ccadf485ecb4d67c35a87270edc4f4b46772d01363d8e8a24c3fabf57d0a65c9c76fbf748dd5611b439ba48baba06cf29ebd6154f2c6d9a94dafd2c95e78a6896e3f5369c03f987ddc9bae8bb1f0b408370e2fcf7e37322c176bfb4b7790e58839face8e3025e05429e55d682098487b736e9ecef9144c5a12593b8bba8a2f6efe817404f503f1e49096542d09cedb01d68d4d0a81e0384b5f20b45e2adb2bd5a9543992e53e222daa4e2403f2db0496c6635b4e7db17b0d20a4f3a4eae304a745e2598f27db3771cb499091b61e4129b4de8ada424e0f8840f9b7c88ddb871e10533e6f6cfcecc23697214822598c16f055f9f4848a6106748038c238d99c1e3bef92b125600d616683a9a169d69fcc787d3a8ddbde81d555c6591aff9ea506afe27c777b44da41538f2b51d40a5d69c4cb8c77a89d41e070bc24d4cbbe5f4bf4beb71ebfb5eb3d0f2731b0b778e6d51cc2b1f9af0623e48485bab48473ef4178ae34e3713e03226634b37c23b86be18953d8d809649f2dd71567e2179fb325c2ef47ca06e8ad216a46034f2c9d04edc75d890346f2b54faf968d7d5abb20c960bd5ac4a37d9971768b8a0274d092813d344f44a14ab7cc67f89e28a1fb18967ea6dd4de0e389a283ce0deb473a71378198184b285e1e70f22e6075cd5fae277a77adcce61f34a1e9ec3073b28e9f05516df1257fa04c28c9ed2b4d8a42710fa977dfa9ed38561693d94d357700d8cb355d0b1c8c4d2e1df41393b2e5635cea95c947eb1d93f2003995565aaca7f07ecbd582dd9f8af6a746649070aa7efb11fe3c73b35933e7238e24cfc87ef62ea15774f9e4e511cc95b5506182b34404a3d2b1f58630c12e023acc4d3f93bee48a0bda028d5717e762a8a1297365018e2a6de2ef7d707f5039d8318c2e21921ad8953182a00a34c1c44446e0c012d7692497b365a172f5dc250b8598b7855dad13d01498e2d7a4182b6c2b0328d9cb951c016dd38a44e91b6b88ba0631bfc051b8ffa4e9f96f91f9288bcd79a73a06537a8b3b4f6a5af50b883a8418c2e7546a548cc55ffeeb68f14c0cc4553e88390f2ae68b7bc156418eb4d33e441193d8b4732fa5d929a9f99ab134ca0b3086598327efeddd6bc68930fd368c68911a09e46349c7633ee3897e1f5159524c93ccfacc4273e5c7e6eb5efbbb9c294334b124b760916f9a5492e3b2c35bd0aa5a5c2077c347f6d2f87ee16cc037a6eb99aa013e9441b9385a1b360fba11601d901ca36e9b8663d315dc7f1a9f70fe2c4ca202a91adb3479033cb9b678965639bd907ceefe480e2780544363123c71056f3724c4f6b14ffe58a9f179869bde502db01c14e4acccc5a8bcd8dde04f67ae5d5aa081359b62eecd367200919437fc49366cbcf1aae6c15c82f6f3ea59cb72c024480aeba3df24a4240cc8b148594560c9c038292c90d305ed9b412a0ecbe8bebef869c91b3107832047a0d61b35de334454dc10e2215d7875fba04aead5c88992978978aeed2b4735cfe2fb573cc9251ca575f525fe9157885dbc355205bf1cd36f14dac71f0f3eed68b912aef2d6912c630b350e93ef44bf68af55b2d94e992f1d3e03f33d966e6b0c5a20d1debdfd03c9eb31755e5113152e2f168d5b6f63450100885dabadc92d2dcaceef89659d811ab2c5b8002a4459832206a2fd147bfecf82a11ed71ce7e0fbd21f3e308dc9faff0258a221f16d60e6b2e0cbe9580beab4eacc81ccaf83b721904e232af7136c2d1cc8007d93305451dcb79d02bf89a50b7267c2bd232955a41962bd3ad3d34771c44bcf1fe7717d5d092e471ee48ff3586cc699d9f006648fcd7f211acdfb4f36096ce39ffe336f06e28c892cee0c9af818504db382a40f58f7166d140063d5bbc11982de8a23b49c1a90ec6e6f056703689a8302bd9e78c960c4648903832857ebc1ae66e612bc3e75c439c61e4918696dd846025c39246526fadc61e9f1a05b61f7a15a9f7696a9e7d7a3a688e600ebadd0ec2b2a41d34fde7fb59c57c659fd7f093e0a8e3f0a266ea4268f1d6164d6c1c4e779d7a31b6b6d5a9d9ac7e45a7786923b48cb2dbc388737b95005bdeefdf5e5758307889537ee75f2e0a9fd99dace5135cd4ac6ad2b6926d5d2b5d67b79442159845b8bca554a8c8584b3adf1f32ea2cc989f6329d8e7ff1e772543f375cb11c9af4636cc49c9729f2cac6ebac31682579af2e06d86888b1329f9dfd3cbff3f1da50867279375e966a74d605a69d497321453f2449e2609da150deb58b57dbad877915ffdda9aca597e6d89a16a0b8619187b108097805841010b85ba97f57e46ddfaf525deb1c5d24762b8d168b0a97bd63f6f3b60ff4c7a759726771f8f9fe02b9705a1fcdee0bd19909665101ed171a239689d4f9af8ada2631d7c14490a0ad8b24af4e67470e08b1279c3560f3b86f1ea7fbf031d9ee5ea94fd3a69cd7b190be59e69af74ae12bf24fb03c4c234ca809d4d6c1028cc00ba189761fa9e82f72eda27c2e7df3c2637bdf7ea728d788ca33cf0d8cc22f99e58f0321b93374137b3f030eea49a7e5d7f24a126e9f9a5483eb86022841ab37b16951292c9f60d73fe1bad9a810648a7aa46015b450819276aff3b6214e1ddf70c747db397f9df57efe61f876eeaeaefedf17d9ecf4cbfbc71baebf40bb33d7eced9f515e8901cfaab3d6beb2e2fb9ae22d54eb2b00dd8e4dffb3c0fe8ffab7b552316494889ec4fd2ad465b5f0372ad6e22b2d6369f52e6aa68e35812c5a55281858b60252e0d01e6d7b55d0df49d4e3cc8959925a09be83dcfd78c90c1707ad0454726b7a85e9ca847c227693d6a1e8c924514d4f673ca452e64ec0fe763368b3eba7735827e4c7085a839deebf79cf90491d13b1dfe4e61143ae8a7f241fecd742d2e772b4601b22e0e727a32b34c93b9cc99d8783c67ccc594b7c62eb015e6c04e6e0d1b86b2de7147b5d48f5addd9c1016194cf76359b9a023f53fb0b7c1754e9131769ba1e750ffbbaf3d85bcd09fc88d8bbb51a77eb650b0327b17b297a724ac695401d9c16b0dbd352dea108eca598b79e894c1cae953137fada640f9c1dae864c34842b2927687990d4e5a8734cf66065c4d895ff79817d601dad0ae8f155e3e7e2f188f1bef23a5d107d9f7ce21219899dded4f03ea8b2ceaaa45de97d8bfe217d12c970074d83e10075bde960ac0ea84828d26f9a8ff214b2d004d204e4cb302677c44a5db3b043de956d4fca55729b11843fcae4fb1b8b933047cb25c32005617c82331497a5c60814c1069d21d142a2cc179d95a9c1728239d6a00c04570c5853d0ac74b86af2c3fa4540ce3c3e4dd071acb3903ac222eeb2cb33522be3a7ac175330d9fe6b46c21b02a782d04e03a6c8eb405a0e50cc8232041202e486847b6006d1893c2de5db00a32f8fef3be07c6d4a1f4bcfa99d80bba9d38d493525163868cd84e07b627a2fc2b76b9c75a55180ea7faa7b59d40a98cb1018ff969e523fd0b2e5b71c334cf21d5ed4b5bc885ca428619a6b2f896f0fe0faf5a4f38d1a19b2a82290067cb162a3ec542ba467a6abdcf1944d68dcfab410bbaa6fea4f7743b3198003f50981db70ea86c8c203fe3c2d1b3712fca98abf33aa0a6d87544e53ff469179b08a57c74b8e963ccf0a2c3df7a314060e7cd1996a90389b45156d8e0c0f486963d7f3caf0891827dc221a354ba3eb59a25da3259aa593426f1d41cdd5988d2ef7886eeca7e945148d531bbb2b0664de912aac345fa4724e33a6533f94f06119e629905aad9ae689ccb6b34d3d7fa0bf125a78c6c960c82ddc73354499f167a1681c97c2c2740236f0075ca3cd8f9796a94184b0306334e21cb116b5e9bca08afdd4df51b869357d2b92b9b8443a65bee69c01bd5775b194277cf818b62e563eb7d722107708f0b3c2f935116dea00c07da251efb2330b393c49a91bffec8b7f46a82f559412d48d78f3778060bb97c79e741d867103ce37154560b1c3d7532a1a0176faf163298e534bacdaefd35ac66daecfb52b80805fd67407c79eebada833fc1fe97ba7a6cc33490ca4555ed24d9f928151696a72904b82fe642b80483eb9c95a644eafd4c590fd5fb52561af6dc40611a2059d5984b18e92ed3d260106bc4104cc77902d15073afbb32ec129b03d69b3143a98cb2226d52091bb1acdc20d2a9ffdc1be74f478ee5aa1333268fe1d4e429149f5289ca6f74c7ab610067d80e6b48ff6159451a5224b9ffdb2b7c8f985bd7d8fa1c43575d0e92783f4c712a4f0f740c227bbbf4efabf222b2755c40d44e53f38df002babccc163b72c653a7099b0b91973203844c0f6d4ac8fafc45e35f9144c63e3c16ffb469fdca32880cde423c792cb540c68540a9d145b82293d5448c80eb0cce8f8a50e02dcd6b1f5aa6ec096a129ff6ba979addf423c50345a2fcf03cb6743153a0c5798b35952c2905eb769e528334117f46fb00a210cbf705f8685c44da3249a3920213af696002dcfdddff79844857f0decead337ae0986c1e7b690c4ca4775013906e3fb3ca06427ff353c05d7c67856ca83d3d0acc30ba0e1490d5af96746e63b543a8182f9d0a5d2652022578bf6b56ac6c199f39ae2431a5d703110eaa0ae590028374bb12fd67b405989088b103ba3c79172376275103affa82a617f4e84bb588c0b7acf80ad58dbdd78fa2f9e78fe20211740eaf4921806d8c6ec9a3b58c6fdaf6aa64131e09e3451861c844504084302e5e60fde8b168b5329f0d6c70677d615f3b8efe1b10031fc43d12be4f591bda6881812ea2f687a9bceb49c76a0682501093bf139dc82a6b857f8da4af9574253e4bf4d7326ad7b55e02ec222e4c399988452a3f1e005efb2f328ac2a039139bc21cfd39313dacac5de48467d514141eb1fda279767c4887db3001ef0fffd595e71efaddef109953a609b3899dc759e493f3b9bc0921eee0cc49492fba9a40d4e1b7584a2be5719d127e5a250f8214cd55173cc0e2c5d9056ea7962911315f19b8559d7929f0487d4e0a11f802364b64ea0090dbd0dcd84b855504a38e1cadfabba2c742e42f6aa3b4af8376f37ff1c2a8e60f51f54328a03502aa98014044d75d1beea9b2547fd95bb2929a7eba3d96d1452672d955f2a3825a08a32e44de759ed4bde77cc7675728b36f0787782de90b7a0a12dc0583337c58e22638caef8403a7f718ab1334a7b721600a0faf60b6c0a9be1d1a68f4ed530851adfc122204d4790effd75d9759d9f0bdf1e13ae0bfd0bf5161433c7e0d3ce2c8bc7267ad12022ef695742f3a7d4acd1a3723c8b6c4e6afcc35ce7f3b84e0f4a05261f386681e571a1be78188cc825345","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"1d6891e32fe802e2b072295258f6b137"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
